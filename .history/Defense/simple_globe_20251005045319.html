<head>
    <link rel="stylesheet" href="style.css" />

    <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
</head>

<body>
    <!-- Controls Sidebar -->
    <div id="controls">
        <h3>Impact Controls</h3>

        <div class="label">
            Projectile Diameter
            <span class="info" data-tip-title="Projectile Diameter"
                data-tip="The size across the asteroid. Larger diameter increases volume ~ d³, mass, and impact energy very quickly."></span>
        </div>
        <div class="row">
            <input id="ui-diameter" type="number" min="1" step="1" value="2300" />
            <select id="ui-unit">
                <option value="m">meters</option>
                <option value="km">kilometers</option>
            </select>
        </div>

        <div class="row">
            <label>Velocity</label>
            <input id="ui-vel" type="range" min="11" max="72" value="20" class="full" />
            <span id="ui-velOut">20</span>
            <span class="unit">km/s</span>
        </div>

        <div class="row">
            <label>Impact Angle</label>
            <input id="ui-angle" type="range" min="0" max="90" value="45" class="full" />
            <span id="ui-angleOut">45</span>
            <span class="unit">degrees</span>
        </div>

        <div class="row">
            <label>Density</label>
            <input id="ui-density" type="number" min="100" step="100" value="3000" />
            <span class="unit">kg/m³</span>
        </div>

        <div class="row">
            <label>Latitude</label>
            <input id="ui-lat" type="number" min="-90" max="90" step="1" value="0" />
            <span class="unit">degrees</span>
        </div>

        <div class="row">
            <label>Longitude</label>
            <input id="ui-lng" type="number" min="-180" max="180" step="1" value="0" />
            <span class="unit">degrees</span>
        </div>

        <button id="simulateBtn">Simulate Impact</button>

        <div class="row">
            <label>Laser Power</label>
            <input id="laser-power" type="range" min="0" max="100" value="50" class="full" />
        </div>

        <div class="row">
            <label>Laser Radius</label>
            <input id="laser-radius" type="range" min="0.05" max="0.5" value="0.15" step="0.01" class="full" />
            <span id="laser-radius-out">0.15</span>
        </div>

        <button id="fire-laser">Fire Laser</button>
        <button id="show-trajectory" style="margin-top: 10px;">Show Trajectory</button>
    </div>

    <div id="globeViz"></div>
    <div id="time"></div>

    <script type="module">
        import {
            BoxGeometry, MeshStandardMaterial, Mesh, MeshBasicMaterial,
            TextureLoader, ShaderMaterial, Vector2, Vector3,
            IcosahedronGeometry, ConeGeometry, SphereGeometry, Group,
            Sprite, SpriteMaterial, CanvasTexture, AdditiveBlending,
            BufferGeometry, LineBasicMaterial, Line, Float32BufferAttribute,
            CylinderGeometry, MeshLambertMaterial
        } from '//cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

        // Global variables
        let world;
        let objects = [];
        let satellites = [];
        let isDeflected = false;
        let trajectoryLine = null;
        let trajectoryGeom = null;
        let trajectoryMat = null;

        // Simple trajectory functions
        function createTrajectoryLine(scene) {
            trajectoryGeom = new BufferGeometry();
            trajectoryMat = new LineBasicMaterial({
                color: 0xff0044,
                transparent: true,
                opacity: 1.0,
                depthTest: false,
                depthWrite: false
            });
            
            trajectoryLine = new Line(trajectoryGeom, trajectoryMat);
            trajectoryLine.visible = false;
            trajectoryLine.renderOrder = 1000;
            
            scene.add(trajectoryLine);
            console.log('Trajectory line created');
        }

        function updateTrajectoryLine() {
            if (!trajectoryLine) return;
            
            const asteroid = objects.find(obj => obj.type === 'asteroid');
            if (!asteroid) {
                trajectoryLine.visible = false;
                console.log('No asteroid found');
                return;
            }
            
            console.log('Updating trajectory for asteroid at:', asteroid.lng, asteroid.lat, asteroid.altitude);
            
            // Convert lng/lat to 3D position
            const toRad = Math.PI / 180;
            const φ = asteroid.lat * toRad;
            const λ = asteroid.lng * toRad;
            const radius = asteroid.altitude + 1;
            
            const asteroidPos = new Vector3(
                Math.cos(φ) * Math.cos(λ) * radius,
                Math.sin(φ) * radius,
                Math.cos(φ) * Math.sin(λ) * radius
            );
            
            console.log('Asteroid 3D position:', asteroidPos);
            
            // Create trajectory line extending from asteroid
            const direction = asteroidPos.clone().normalize();
            const startPoint = asteroidPos.clone().add(direction.clone().multiplyScalar(-20));
            const endPoint = asteroidPos.clone().add(direction.clone().multiplyScalar(5));
            
            console.log('Trajectory from:', startPoint, 'to:', endPoint);
            
            const points = [
                startPoint.x, startPoint.y, startPoint.z,
                asteroidPos.x, asteroidPos.y, asteroidPos.z,
                endPoint.x, endPoint.y, endPoint.z
            ];
            
            const positionArray = new Float32BufferAttribute(points, 3);
            trajectoryGeom.setAttribute('position', positionArray);
            trajectoryGeom.computeBoundingSphere();
            
            trajectoryLine.visible = true;
            console.log('Trajectory updated with', points.length / 3, 'points');
        }

        // Notification system
        function showNotification(message, type = 'info', duration = 3000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            });

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-text">${message}</span>
                    <button class="notification-close">×</button>
                </div>
            `;

            document.body.appendChild(notification);

            // Show notification with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Auto hide
            const autoHideTimer = setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, duration);

            // Manual close
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.addEventListener('click', () => {
                clearTimeout(autoHideTimer);
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            });
        }

        // Start main code
        (async () => {
            const timeEl = document.getElementById('time');
            const IMPACT = { lat: 0, lng: 0 };
            const asteroid = { type: 'asteroid', lat: IMPACT.lat, lng: IMPACT.lng, altitude: 3.0 };
            objects.push(asteroid);

            let hasImpacted = false;
            let satellite;

            // Convert lng/lat to 3D vector
            function lngLatToVec(lngDeg, latDeg) {
                const toRad = Math.PI / 180;
                const φ = latDeg * toRad, λ = lngDeg * toRad;
                return new Vector3(
                    Math.cos(φ) * Math.cos(λ),
                    Math.sin(φ),
                    Math.cos(φ) * Math.sin(λ)
                );
            }

            const world = new Globe(document.getElementById('globeViz'));

            // Build geodesic circle coordinates
            function circleCoords(lng, lat, radiusDeg, steps = 96) {
                const coords = [];
                const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
                const φ1 = lat * toRad, λ1 = lng * toRad;
                const δ = radiusDeg * toRad;
                const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
                for (let i = 0; i <= steps; i++) {
                    const bearing = (i / steps) * 2 * Math.PI;
                    const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
                    const sinα = Math.sin(bearing), cosα = Math.cos(bearing);
                    const y = sinδ * cosφ1 * sinα;
                    const x = cosδ - sinφ1 * Math.sin(Math.asin(Math.sqrt(y * y + (sinδ * cosφ1 * cosα + cosδ * sinφ1) ** 2)));
                    const φ2 = φ1 + Math.atan2(y, x);
                    const λ2 = λ1 + Math.atan2(sinδ * sinα, cosφ1 * cosδ - sinφ1 * sinδ * cosα);
                    coords.push([λ2 * toDeg, φ2 * toDeg]);
                }
                return coords;
            }

            // Laser system
            let laserMesh = null;
            let laserRadius = 0.15;
            let isLaserActive = false;

            function fireLaser() {
                console.log('Firing laser...');
                
                const asteroidTarget = objects.find(obj => obj.type === 'asteroid');
                if (!asteroidTarget) {
                    showNotification('No asteroid target found!', 'error');
                    return;
                }

                // Create laser beam
                if (laserMesh) {
                    world.scene().remove(laserMesh);
                }

                const satPos = new Vector3(0, 0, 2); // Simplified satellite position
                const astPos = lngLatToVec(asteroidTarget.lng, asteroidTarget.lat).multiplyScalar(asteroidTarget.altitude + 1);
                const distance = satPos.distanceTo(astPos);

                const laserGeom = new CylinderGeometry(laserRadius, laserRadius, distance, 8);
                const laserMat = new MeshLambertMaterial({ 
                    color: 0xff0000, 
                    transparent: true, 
                    opacity: 0.8,
                    emissive: 0x440000
                });

                laserMesh = new Mesh(laserGeom, laserMat);
                laserMesh.position.copy(satPos).add(astPos).multiplyScalar(0.5);
                laserMesh.lookAt(astPos);
                laserMesh.rotateX(Math.PI / 2);

                world.scene().add(laserMesh);

                // Deflect asteroid
                isDeflected = true;
                asteroidTarget.deflected = true;
                
                showNotification('Laser fired! Asteroid deflected successfully!', 'success');
                
                // Update trajectory to show deflection
                if (trajectoryMat) {
                    trajectoryMat.color.setHex(0x00ff00); // Green for deflected
                }
                updateTrajectoryLine();

                // Remove laser after 2 seconds
                setTimeout(() => {
                    if (laserMesh) {
                        world.scene().remove(laserMesh);
                        laserMesh = null;
                    }
                }, 2000);
            }

            // Load assets and initialize
            const [dayTexture, nightTexture] = await Promise.all([
                new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
                new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg')
            ]);

            const material = new ShaderMaterial({
                uniforms: {
                    dayTexture: { value: dayTexture },
                    nightTexture: { value: nightTexture },
                    sunPosition: { value: new Vector2(0, 23.4) },
                    globeRotation: { value: new Vector2() }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    #define PI 3.141592653589793
                    uniform sampler2D dayTexture;
                    uniform sampler2D nightTexture;
                    uniform vec2 sunPosition;
                    uniform vec2 globeRotation;
                    varying vec3 vNormal;
                    varying vec2 vUv;

                    float toRad(in float a) {
                        return a * PI / 180.0;
                    }

                    vec3 Polar2Cartesian(in vec2 c) {
                        float theta = toRad(90.0 - c.x);
                        float phi = toRad(90.0 - c.y);
                        return vec3(
                            sin(phi) * cos(theta),
                            cos(phi),
                            sin(phi) * sin(theta)
                        );
                    }

                    void main() {
                        float invLon = toRad(globeRotation.x);
                        float invLat = -toRad(globeRotation.y);
                        mat3 rotX = mat3(
                            1, 0, 0,
                            0, cos(invLat), -sin(invLat),
                            0, sin(invLat), cos(invLat)
                        );
                        mat3 rotY = mat3(
                            cos(invLon), 0, sin(invLon),
                            0, 1, 0,
                            -sin(invLon), 0, cos(invLon)
                        );
                        vec3 rotatedSunDirection = rotX * rotY * Polar2Cartesian(sunPosition);
                        float intensity = dot(normalize(vNormal), normalize(rotatedSunDirection));
                        vec4 dayColor = texture2D(dayTexture, vUv);
                        vec4 nightColor = texture2D(nightTexture, vUv);
                        float blendFactor = smoothstep(-0.1, 0.1, intensity);
                        gl_FragColor = mix(nightColor, dayColor, blendFactor);
                    }
                `
            });

            // Setup globe
            world
                .globeMaterial(material)
                .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
                .objectsData(objects)
                .objectLat('lat')
                .objectLng('lng')
                .objectAltitude('altitude')
                .objectFacesSurface(false)
                .objectThreeObject(() => {
                    const rockMesh = new Mesh(
                        new IcosahedronGeometry(0.07, 1),
                        new MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    return rockMesh;
                })
                .onZoom(({ lng, lat }) => material.uniforms.globeRotation.value.set(lng, lat));

            // Initialize trajectory system
            createTrajectoryLine(world.scene());

            // Animation loop
            const dt = new Date();
            const time = 0.1 * dt;
            
            function animate() {
                // Simple asteroid movement
                const asteroid = objects.find(obj => obj.type === 'asteroid');
                if (asteroid && !hasImpacted) {
                    asteroid.altitude = Math.max(0, asteroid.altitude - 0.001);
                    if (asteroid.altitude <= 0.1) {
                        hasImpacted = true;
                        showNotification('Impact detected!', 'warning');
                    }
                }

                // Update trajectory
                updateTrajectoryLine();

                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);

            // UI Event Listeners
            const els = {
                diameter: document.getElementById('ui-diameter'),
                unit: document.getElementById('ui-unit'),
                density: document.getElementById('ui-density'),
                angle: document.getElementById('ui-angle'),
                angleOut: document.getElementById('ui-angleOut'),
                vel: document.getElementById('ui-vel'),
                velOut: document.getElementById('ui-velOut'),
                lat: document.getElementById('ui-lat'),
                lng: document.getElementById('ui-lng'),
                simulate: document.getElementById('simulateBtn'),
                laserPower: document.getElementById('laser-power'),
                laserRadius: document.getElementById('laser-radius'),
                laserRadiusOut: document.getElementById('laser-radius-out'),
                fireLaser: document.getElementById('fire-laser'),
                showTrajectory: document.getElementById('show-trajectory')
            };

            // Button event listeners
            els.fireLaser.addEventListener('click', fireLaser);
            
            els.showTrajectory.addEventListener('click', () => {
                console.log('Show trajectory clicked');
                updateTrajectoryLine();
                if (trajectoryLine) {
                    trajectoryLine.visible = !trajectoryLine.visible;
                    console.log('Trajectory visibility:', trajectoryLine.visible);
                }
            });

            els.laserRadius.addEventListener('input', () => {
                laserRadius = Number(els.laserRadius.value);
                els.laserRadiusOut.textContent = laserRadius.toFixed(2);
            });

            // Slider updates
            els.angle.addEventListener('input', () => {
                els.angleOut.textContent = els.angle.value;
            });

            els.vel.addEventListener('input', () => {
                els.velOut.textContent = els.vel.value;
            });

            console.log('Asteroid defense system initialized');
            showNotification('Asteroid defense system ready!', 'success');
        })();
    </script>
</body>