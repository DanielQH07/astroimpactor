<head>
    <link rel="stylesheet" href="style.css" />

    <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
    <!--  <script src="../../dist/globe.gl.js"></script>-->
</head>

<body>
    <!-- Controls Sidebar -->
    <div id="controls">
        <h3>Impact Controls</h3>

        <div class="label">
            Projectile Diameter
            <span class="info" data-tip-title="Projectile Diameter"
                data-tip="The size across the asteroid. Larger diameter increases volume ~ d³, mass, and impact energy very quickly."></span>
        </div>
        <div class="row">
            <input id="ui-diameter" type="number" min="1" step="1" value="2300" />
            <select id="ui-unit">
                <option value="m" selected>m</option>
                <option value="km">km</option>
            </select>
        </div>

        <div class="label">
            Density (kg/m³)
            <span class="info" data-tip-title="Density"
                data-tip="Material heaviness. Higher density means more mass for the same size, so the impact is more energetic."></span>
        </div>
        <div class="row">
            <input id="ui-density" type="number" min="500" step="10" value="2750" class="full" />
        </div>

        <hr style="border-color: rgba(255,255,255,0.1); margin: 10px 0;">

        <div class="label">
            Impact Angle: <span id="ui-angleOut" class="muted">45°</span>
            <span class="info" data-tip-title="Impact Angle"
                data-tip="Angle above the ground at the impact point. 0° is a skim across the surface, 90° is straight down. It also sets the approach direction in the animation."></span>
        </div>
        <div class="row">
            <input id="ui-angle" type="range" min="0" max="90" step="1" value="45" class="full" />
        </div>

        <div class="label">
            Velocity: <span id="ui-velOut" class="muted">20 km/s</span>
            <span class="info" data-tip-title="Velocity"
                data-tip="Entry speed (km/s). Impact energy grows with v², so small changes in speed can greatly change the blast."></span>
        </div>
        <div class="row">
            <input id="ui-vel" type="range" min="11" max="72" step="1" value="20" class="full" />
        </div>

        <hr style="border-color: rgba(255,255,255,0.1); margin: 10px 0;">

        <div class="label">
            Latitude (°)
            <span class="info" data-tip-title="Latitude"
                data-tip="North-south location of the impact. Positive is Northern Hemisphere, negative is Southern Hemisphere."></span>
        </div>
        <div class="row">
            <input id="ui-lat" type="number" min="-90" max="90" step="0.1" value="0" class="full" />
        </div>

        <div class="label">
            Longitude (°)
            <span class="info" data-tip-title="Longitude"
                data-tip="East-west location of the impact. Positive is Eastern Hemisphere, negative is Western Hemisphere."></span>
        </div>
        <div class="row">
            <input id="ui-lng" type="number" min="-180" max="180" step="0.1" value="0" class="full" />
        </div>

        <button id="simulateBtn">Simulate</button>

        <hr style="border-color: rgba(255,255,255,0.1); margin: 10px 0;">

        <div class="label">Laser Power</div>
        <div class="row">
            <label>Laser Radius</label>
            <input id="laser-radius" type="range" min="0.01" max="0.5" value="0.05" step="0.01" class="full" />
            <span id="laser-radius-out">0.05</span>
        </div>

        <div class="row">
            <input id="laser-power" type="range" min="0" max="100" value="50" class="full" />
        </div>

        <button id="fire-laser">Fire Laser</button>
    </div>

    <div id="globeViz"></div>
    <div id="time"></div>

    <script type="module">
        import {
            BoxGeometry, MeshStandardMaterial, Mesh, MeshBasicMaterial,
            TextureLoader, ShaderMaterial, Vector2, Vector3,
            IcosahedronGeometry, ConeGeometry, SphereGeometry, Group,
            CanvasTexture, SpriteMaterial, AdditiveBlending, Sprite,
            BufferGeometry, Float32BufferAttribute, PointsMaterial, Points,
            TetrahedronGeometry, LineBasicMaterial, LineLoop, CylinderGeometry,
            TubeGeometry, CatmullRomCurve3, Raycaster, Quaternion
        } from 'https://esm.sh/three';
        import { GLTFLoader } from 'https://esm.sh/three/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://esm.sh/three/examples/jsm/loaders/DRACOLoader.js';
        import * as solar from 'https://esm.sh/solar-calculator';

        const dayNightShader = {
            vertexShader: `
	varying vec3 vNormal;
	varying vec2 vUv;
	void main() {
	  vNormal = normalize(normalMatrix * normal);
	  vUv = uv;
	  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
  `,
            fragmentShader: `
	#define PI 3.141592653589793
	uniform sampler2D dayTexture;
	uniform sampler2D nightTexture;
	uniform vec2 sunPosition;
	uniform vec2 globeRotation;
	varying vec3 vNormal;
	varying vec2 vUv;

	float toRad(in float a) {
	  return a * PI / 180.0;
	}

	vec3 Polar2Cartesian(in vec2 c) { // [lng, lat]
	  float theta = toRad(90.0 - c.x);
	  float phi = toRad(90.0 - c.y);
	  return vec3( // x,y,z
		sin(phi) * cos(theta),
		cos(phi),
		sin(phi) * sin(theta)
	  );
	}

	void main() {
	  float invLon = toRad(globeRotation.x);
	  float invLat = -toRad(globeRotation.y);
	  mat3 rotX = mat3(
		1, 0, 0,
		0, cos(invLat), -sin(invLat),
		0, sin(invLat), cos(invLat)
	  );
	  mat3 rotY = mat3(
		cos(invLon), 0, sin(invLon),
		0, 1, 0,
		-sin(invLon), 0, cos(invLon)
	  );
	  vec3 rotatedSunDirection = rotX * rotY * Polar2Cartesian(sunPosition);
	  float intensity = dot(normalize(vNormal), normalize(rotatedSunDirection));
	  vec4 dayColor = texture2D(dayTexture, vUv);
	  vec4 nightColor = texture2D(nightTexture, vUv);
	  float blendFactor = smoothstep(-0.1, 0.1, intensity);
	  gl_FragColor = mix(nightColor, dayColor, blendFactor);
	}
  `
        };

        const sunPosAt = dt => {
            const day = new Date(+dt).setUTCHours(0, 0, 0, 0);
            const t = solar.century(dt);
            const longitude = (day - dt) / 864e5 * 360 - 180;
            return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
        };

        // Set fixed UTC time (no continuous change)
        let dt = +new Date(); // now
        const timeEl = document.getElementById('time');
        timeEl.textContent = new Date(dt).toUTCString();

        const world = new Globe(document.getElementById('globeViz'));

        // Build geodesic circle coordinates (lng/lat pairs) around a center
        function circleCoords(lng, lat, radiusDeg, steps = 96) {
            const coords = [];
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const φ1 = lat * toRad, λ1 = lng * toRad;
            const δ = radiusDeg * toRad;
            const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
            const sinδ = Math.sin(δ), cosδ = Math.cos(δ);

            for (let i = 0; i <= steps; i++) {
                const θ = 2 * Math.PI * i / steps;
                const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * Math.cos(θ);
                const φ2 = Math.asin(sinφ2);
                const y = Math.sin(θ) * sinδ * cosφ1;
                const x = cosδ - sinφ1 * sinφ2;
                const λ2 = λ1 + Math.atan2(y, x);
                const lng2 = ((λ2 * toDeg + 540) % 360) - 180;
                const lat2 = φ2 * toDeg;
                coords.push([lng2, lat2]);
            }
            return coords;
        }

        // Geodesic boundary from an angle-dependent radius function
        function radialCoords(lng, lat, angles, rFn) {
            const coords = [];
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const phi1 = lat * toRad, lambda1 = lng * toRad;
            const sinPhi1 = Math.sin(phi1), cosPhi1 = Math.cos(phi1);

            for (let i = 0; i < angles.length; i++) {
                const theta = angles[i];
                let rDeg = Math.max(0.0001, rFn(theta));
                const delta = rDeg * toRad;
                const sinDelta = Math.sin(delta), cosDelta = Math.cos(delta);

                const sinPhi2 = sinPhi1 + cosPhi1 * sinDelta * Math.cos(theta) * 0 + (sinPhi1 * (cosDelta - 1)); // stabilize
                const phi2 = Math.asin(sinPhi1 * cosDelta + cosPhi1 * sinDelta * Math.cos(theta));

                const y = Math.sin(theta) * sinDelta * cosPhi1;
                const x = cosDelta - sinPhi1 * Math.sin(phi2);
                const lambda2 = lambda1 + Math.atan2(y, x);

                const lng2 = ((lambda2 * toDeg + 540) % 360) - 180;
                const lat2 = phi2 * toDeg;
                coords.push([lng2, lat2]);
            }
            return coords;
        }

        // Irregular, spiky crater with gradient bands (replaces previous buildCrater)
        function buildCrater(center, innerRadiusDeg = 1.2, outerRadiusDeg = 2.1) {
            const steps = 192;
            const angles = Array.from({ length: steps + 1 }, (_, i) => 2 * Math.PI * i / steps);

            // Shape controls
            const phase1 = Math.random() * Math.PI * 2;
            const phase2 = Math.random() * Math.PI * 2;
            const phase3 = Math.random() * Math.PI * 2;

            // Elliptical bias (overall non-roundness)
            const ellipseAngle = Math.random() * Math.PI * 2;
            const ellipseAmpDeg = 0.22; // deg

            // Localized outward spikes (ejecta-like rays)
            const spikeCount = 8;
            const spikes = Array.from({ length: spikeCount }, () => ({
                theta: Math.random() * Math.PI * 2,
                amp: 0.22 + Math.random() * 0.25 // deg
            }));
            const spikeSigma = 0.09;

            const wrap = a => Math.atan2(Math.sin(a), Math.cos(a));
            const spikeBoost = theta => {
                let s = 0;
                for (const sp of spikes) {
                    const d = wrap(theta - sp.theta);
                    s += sp.amp * Math.exp(-0.5 * (d / spikeSigma) * (d / spikeSigma));
                }
                return s;
            };

            // Base noise (multi-harmonic)
            const baseNoise = theta =>
                0.16 * Math.sin(3 * theta + phase1) +
                0.09 * Math.sin(5 * theta + phase2) +
                0.05 * Math.sin(9 * theta + phase3);

            // Bias in degrees at angle theta
            const biasDeg = theta =>
                ellipseAmpDeg * Math.cos(theta - ellipseAngle) +
                baseNoise(theta) +
                spikeBoost(theta);

            // Helper: coords for a given base radius with amplitude scaling
            const coordsFor = (rBaseDeg, ampScale) =>
                radialCoords(center.lng, center.lat, angles, th => rBaseDeg + ampScale * biasDeg(th));

            const features = [];
            const bands = 24;
            const total = outerRadiusDeg - innerRadiusDeg;
            const dr = total / bands;

            // Center disk (irregular but mild)
            const centerAmp = 0.4; // lower jaggedness at core
            let innerCoords = coordsFor(innerRadiusDeg, centerAmp);
            features.push({
                type: 'Feature',
                properties: { kind: 'band', color: 'rgba(255,0,0,0.9)', altitude: 0.003 },
                geometry: { type: 'Polygon', coordinates: [innerCoords] }
            });

            // Concentric irregular annuli with increasing jaggedness and spikes
            for (let i = 0; i < bands; i++) {
                const r1Base = innerRadiusDeg + (i + 1) * dr;
                const t = (r1Base - innerRadiusDeg) / total; // 0..1 from core to rim
                const ampScale = 0.5 + 0.7 * t; // more jagged outward

                const outerCoords = coordsFor(r1Base, ampScale);

                // Color gradient red -> orange with slight transparency drop
                const g = Math.round(140 * t);
                const a = 0.9 + (0.65 - 0.9) * t;
                const color = `rgba(255,${g},0,${a})`;

                features.push({
                    type: 'Feature',
                    properties: { kind: 'band', color, altitude: 0.002 + i * 0.00002 },
                    geometry: { type: 'Polygon', coordinates: [outerCoords, innerCoords.slice().reverse()] }
                });

                // Next band starts at this outer boundary
                innerCoords = outerCoords;
            }

            return features;
        }

        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        gltfLoader.setDRACOLoader(dracoLoader);

        Promise.all([
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg'),
            gltfLoader.loadAsync('aurab.glb')
        ]).then(([dayTexture, nightTexture, satelliteGltf]) => {
            console.log('Satellite GLTF loaded:', satelliteGltf);
            const material = new ShaderMaterial({
                uniforms: {
                    dayTexture: { value: dayTexture },
                    nightTexture: { value: nightTexture },
                    sunPosition: { value: new Vector2() },
                    globeRotation: { value: new Vector2() }
                },
                vertexShader: dayNightShader.vertexShader,
                fragmentShader: dayNightShader.fragmentShader
            });

            // Compute sun position once for current UTC
            const sunNow = sunPosAt(dt);
            material.uniforms.sunPosition.value.set(...sunNow);

            // Shockwave ring config
            const colorInterpolator = t => `rgba(255,100,50,${Math.sqrt(1 - t)})`;

            // Impact location and asteroid object
            const IMPACT = { lat: 0, lng: 0 }; // change as desired
            let objects = [];
            const asteroid = { type: 'asteroid', lat: IMPACT.lat, lng: IMPACT.lng, altitude: 3.0 };
            objects.push(asteroid);

            // Build irregular asteroid mesh
            const rockGeom = new IcosahedronGeometry(1.2, 1);
            const pos = rockGeom.attributes.position;
            const tmp = new Vector3();
            for (let i = 0; i < pos.count; i++) {
                tmp.fromBufferAttribute(pos, i)
                    .normalize()
                    .multiplyScalar(1.1 + Math.random() * 0.7); // jagged
                pos.setXYZ(i, tmp.x, tmp.y, tmp.z);
            }
            rockGeom.computeVertexNormals();
            const rockMat = new MeshStandardMaterial({
                color: 0x666666,
                roughness: 1,
                metalness: 0.05,
                emissive: 0x442200,
                emissiveIntensity: 0.8
            });
            const rockMesh = new Mesh(rockGeom, rockMat);

            // Fiery tail layers
            const tailHeightMid = 6;
            const tailRadiusMid = 1.5;
            const tailGeomMid = new ConeGeometry(tailRadiusMid, tailHeightMid, 20, 1, true);
            tailGeomMid.translate(0, tailHeightMid / 2, 0);
            const tailMatMid = new MeshBasicMaterial({
                color: 0xff7a00,
                transparent: true,
                opacity: 0.8,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailMid = new Mesh(tailGeomMid, tailMatMid);

            // Inner white-hot core
            const tailHeightCore = 4.2;
            const tailRadiusCore = 0.9;
            const tailGeomCore = new ConeGeometry(tailRadiusCore, tailHeightCore, 18, 1, true);
            tailGeomCore.translate(0, tailHeightCore / 2, 0);
            const tailMatCore = new MeshBasicMaterial({
                color: 0xffffcc,
                transparent: true,
                opacity: 0.95,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailCore = new Mesh(tailGeomCore, tailMatCore);

            // Outer red haze
            const tailHeightOuter = 7.5;
            const tailRadiusOuter = 2.2;
            const tailGeomOuter = new ConeGeometry(tailRadiusOuter, tailHeightOuter, 16, 1, true);
            tailGeomOuter.translate(0, tailHeightOuter / 2, 0);
            const tailMatOuter = new MeshBasicMaterial({
                color: 0xff2200,
                transparent: true,
                opacity: 0.45,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailOuter = new Mesh(tailGeomOuter, tailMatOuter);

            // Small radial glow sprite at the base
            function makeGlowSprite(size = 64, inner = 'rgba(255,255,200,1)', outer = 'rgba(255,120,0,0)') {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                g.addColorStop(0, inner);
                g.addColorStop(1, outer);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size, size);
                const tex = new CanvasTexture(canvas);
                const mat = new SpriteMaterial({ map: tex, transparent: true, blending: AdditiveBlending, depthWrite: false, opacity: 0.8 });
                const spr = new Sprite(mat);
                spr.scale.set(6, 6, 1);
                return spr;
            }
            const glowSprite = makeGlowSprite();

            // Group asteroid body + tail (via pivot for camera-relative orientation)
            const asteroidGroup = new Group();
            asteroidGroup.add(rockMesh);
            // asteroidGroup.add(tailMesh); // replaced by tailPivot to control orientation
            const tailPivot = new Group();
            // Align cone axis (+Y) to +Z so we can stretch along Z for length
            tailCore.rotation.x = Math.PI / 2;
            tailMid.rotation.x = Math.PI / 2;
            tailOuter.rotation.x = Math.PI / 2;
            glowSprite.position.z = 0.6; // just behind the rock

            tailPivot.add(tailOuter);
            tailPivot.add(tailMid);
            tailPivot.add(tailCore);
            tailPivot.add(glowSprite);
            asteroidGroup.add(tailPivot);

            // Satellite
            satelliteGltf.scene.scale.set(1, 1, 1); // adjust scale as needed
            const satelliteMesh = satelliteGltf.scene;
            const satellite = { type: 'satellite', lat: 0, lng: 0, altitude: 1.1, object: satelliteMesh };
            objects.push(satellite);

            // Laser system
            let laserRadius = 0.15; // Increased from 0.05 to 0.15 for better visibility
            const laserGeom = new CylinderGeometry(laserRadius, laserRadius, 1, 8);
            const laserMat = new MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.9,
                emissive: 0xff0000,
                emissiveIntensity: 0.7 // Increased intensity
            });
            const laserMesh = new Mesh(laserGeom, laserMat);
            laserMesh.visible = false;
            world.scene().add(laserMesh);

            // Mouse interaction variables
            let isMouseDown = false;
            let isLaserActive = false;
            const raycaster = new Raycaster();
            const mouse = new Vector2();

            // Satellite orbit pre-drawn as custom line
            function lngLatToVec(lngDeg, latDeg) {
                const toRad = Math.PI / 180;
                const φ = latDeg * toRad, λ = lngDeg * toRad;
                return new Vector3(
                    Math.cos(φ) * Math.cos(λ),
                    Math.sin(φ),
                    Math.cos(φ) * Math.sin(λ)
                );
            }
            const orbitPoints = [];
            const numPoints = 360;
            const orbitRadius = 1 + satellite.altitude; // 1 + 1.1 = 2.1
            for (let i = 0; i < numPoints; i++) {
                const lng = (i / numPoints) * 360 - 180;
                const lat = 0; // equatorial orbit
                const vec = lngLatToVec(lng, lat).multiplyScalar(orbitRadius);
                orbitPoints.push(vec);
            }
            // Create a thick orbit line using TubeGeometry for better visibility
            // Create orbit line với thickness nhỏ hơn
            const orbitCurve = new CatmullRomCurve3(orbitPoints, true);
            const orbitGeom = new TubeGeometry(orbitCurve, 360, 0.02, 8, true); // radius 0.02 thay vì 1
            const orbitMat = new MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
            const orbitLine = new Mesh(orbitGeom, orbitMat);
            world.scene().add(orbitLine);
            objects.push(satellite);

            // Scale asteroid initial size
            function applyAsteroidScale() {
                const b = computeBlast();
                asteroidGroup.scale.set(b.asteroidScale, b.asteroidScale, b.asteroidScale);
            }
            applyAsteroidScale();

            // Map UI lat/lng into IMPACT (with clamping)
            function applyImpactFromUI() {
                const toNum = (v, def) => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : def;
                };
                const lat = Math.max(-90, Math.min(90, toNum(els.lat?.value, ui.lat)));
                const lng = Math.max(-180, Math.min(180, toNum(els.lng?.value, ui.lng)));
                IMPACT.lat = lat;
                IMPACT.lng = lng;
            }

            // STRAIGHT-LINE approach based on impact angle (no great-circle)
            let approachStart = null;   // THREE.Vector3
            let approachEnd = null;     // THREE.Vector3
            let approachDir = null;     // THREE.Vector3 (unit)
            let approachLen = 0;        // scalar
            let approachProgress = 0;   // distance traveled along the line
            // Replace fixed speed with slider-driven speed
            const R = 1;                // globe radius in world units for conversion
            const BASE_RPS = 0.6, V0_KMS = 20; // 0.6 radii/s at 20 km/s baseline
            let approachSpeedRps = BASE_RPS;
            function recomputeApproachSpeed() {
                const v = Number(els.vel?.value ?? ui.velocityKms); // km/s from UI
                const mul = Math.pow(v / V0_KMS, 0.8);              // responsive but not extreme
                approachSpeedRps = Math.min(2.5, Math.max(0.2, BASE_RPS * mul));
            }
            function vecToLngLatAlt(v) {
                const toDeg = 180 / Math.PI;
                const r = v.length();
                const p = v.clone().divideScalar(r);
                const lat = Math.asin(p.y) * toDeg;
                const lng = Math.atan2(p.z, p.x) * toDeg;
                const alt = r - R;
                return { lng, lat, alt };
            }

            function setupStraightApproach() {
                // Impact frame
                const n = lngLatToVec(IMPACT.lng, IMPACT.lat).normalize(); // surface normal (up)
                // East direction tangent at impact point
                const east = new Vector3(-Math.sin(IMPACT.lng * Math.PI / 180), 0, Math.cos(IMPACT.lng * Math.PI / 180)).normalize();

                // Angle alpha from horizontal (0=grazing, 90=vertical)
                const alphaDeg = Number(els.angle?.value ?? ui.angleDeg);
                const alpha = Math.max(1, Math.min(89, alphaDeg)) * Math.PI / 180;

                // Approach direction: from west -> towards impact along +east; we come FROM west so direction points towards impact:
                // d points toward the impact along east and downward along normal
                const d = east.clone().multiplyScalar(Math.cos(alpha)).add(n.clone().multiplyScalar(-Math.sin(alpha))).normalize();

                // Line endpoints: start some distance away along -d from the surface point
                const D = 3.0 * R; // radii away from surface along the line (keeps start above the globe for all angles)
                approachEnd = n.clone().multiplyScalar(R);              // exactly at surface
                approachStart = approachEnd.clone().add(d.clone().multiplyScalar(-D));
                approachDir = approachEnd.clone().sub(approachStart).normalize();
                approachLen = approachEnd.distanceTo(approachStart);
                approachProgress = 0;

                // Place asteroid at start
                const cur = approachStart.clone();
                const llh = vecToLngLatAlt(cur);
                asteroid.lat = llh.lat;
                asteroid.lng = llh.lng;
                asteroid.altitude = llh.alt;
            }

            // Initial placement from UI + angle
            applyImpactFromUI();
            setupStraightApproach();
            recomputeApproachSpeed(); // NEW: set initial speed from slider
            world.objectsData(objects);

            // Explosion group (built on impact)
            let explosionGroup = null;
            let explosionStart = 0;
            // Slightly shorter duration
            let explosionDuration = 2000; // was const
            // Track crater placement to ensure single-time creation
            let craterPlaced = false;

            // Replace createExplosion: adds debrisContainer, lowers speeds
            function createExplosion() {
                // Core flash
                const coreGeom = new IcosahedronGeometry(0.15, 2);
                const coreMat = new MeshBasicMaterial({
                    color: 0xfff2aa,
                    transparent: true,
                    opacity: 1,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const core = new Mesh(coreGeom, coreMat);

                // Fireball shell
                const fireballGeo = new SphereGeometry(0.32, 20, 16);
                const fireballMat = new MeshBasicMaterial({
                    color: 0xff9922,
                    transparent: true,
                    opacity: 0.75,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const fireball = new Mesh(fireballGeo, fireballMat);

                // Debris particles (Points)
                const particleCount = 320;
                const debrisGeom = new BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const debrisVel = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3 + 0] = (Math.random() - 0.5) * 0.15;
                    positions[i3 + 1] = (Math.random() - 0.5) * 0.15;
                    positions[i3 + 2] = (Math.random() - 0.5) * 0.15;
                    // Lower particle speed
                    const th = Math.random() * Math.PI * 2;
                    const ph = Math.acos(2 * Math.random() - 1);
                    const base = 0.6 + Math.random() * 1.2; // previous low speed
                    const speed = base * (blast?.debrisSpeedMul ?? 1);
                    debrisVel[i3 + 0] = Math.sin(ph) * Math.cos(th) * speed;
                    debrisVel[i3 + 1] = Math.sin(ph) * Math.sin(th) * speed;
                    debrisVel[i3 + 2] = Math.cos(ph) * speed;
                }
                debrisGeom.setAttribute('position', new Float32BufferAttribute(positions, 3));
                const debrisMat = new PointsMaterial({
                    color: 0xffbb66,
                    size: 0.06,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const debrisPoints = new Points(debrisGeom, debrisMat);

                // Shards (also scaled by debrisSpeedMul)
                const shards = [];
                const shardCount = 24;
                const shardGeo = new TetrahedronGeometry(0.08);
                for (let i = 0; i < shardCount; i++) {
                    const m = new Mesh(
                        shardGeo,
                        new MeshBasicMaterial({
                            color: 0xcc8844,
                            transparent: true,
                            opacity: 0.9,
                            blending: AdditiveBlending,
                            depthWrite: false
                        })
                    );
                    m.position.set((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                    const th = Math.random() * Math.PI * 2;
                    const ph = Math.acos(2 * Math.random() - 1);
                    const base = 0.5 + Math.random() * 1.0;
                    const speed = base * (blast?.debrisSpeedMul ?? 1);
                    m.userData.vel = new Vector3(
                        Math.sin(ph) * Math.cos(th) * speed,
                        Math.sin(ph) * Math.sin(th) * speed,
                        Math.cos(ph) * speed
                    );
                    m.userData.rot = new Vector3(
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6
                    );
                    shards.push(m);
                }

                // Debris container (neutralize group scaling)
                const debrisContainer = new Group();
                debrisContainer.add(debrisPoints);
                shards.forEach(s => debrisContainer.add(s));

                const g = new Group();
                g.add(fireball);
                g.add(core);
                g.add(debrisContainer);

                return {
                    group: g,
                    core, coreMat,
                    fireball, fireballMat,
                    debrisContainer,
                    debrisPoints, debrisGeom, debrisMat, debrisVel,
                    shards
                };
            }

            // Simple reset that re-applies parameters and restarts the fall
            function resetSimulation() {
                console.log('Simulation reset');
                blast = computeBlast();
                applyAsteroidScale();
                applyImpactFromUI();

                // clear visuals
                world.ringsData([]);
                world.polygonsData([]);
                if (explosionGroup) explosionGroup = null;

                // Reset straight-line approach
                objects.length = 0;
                setupStraightApproach();
                recomputeApproachSpeed(); // NEW: refresh speed from current slider
                objects.push(asteroid);
                objects.push(satellite); // add satellite back
                world.objectsData(objects);

                hasImpacted = false;
                craterPlaced = false;
                satelliteAngle = 90; // reset satellite position
            }
            els.simulate.addEventListener('click', resetSimulation);

            // Update approach when changing angle (before impact)
            els.angle.addEventListener('change', () => {
                if (!hasImpacted) {
                    applyImpactFromUI();
                    setupStraightApproach();
                    world.objectsData(objects);
                }
            });

            // NEW: update speed live when Velocity slider changes (before impact)
            els.vel.addEventListener('input', () => {
                if (!hasImpacted) recomputeApproachSpeed();
            });

            // --- Add Tunguska marker (DOM-based popup) ---
            const TUNGUSKA = { lat: 60 + 55 / 60, lng: 101 + 57 / 60, id: 'tunguska' };

            // Helper to fill UI and run the simulation with preset Tunguska params
            function runTunguskaSimulation() {
                // Prefill UI as in your screenshot/baseline
                els.diameter.value = '60';
                els.unit.value = 'm';
                els.density.value = '2750';
                els.angle.value = '45';
                els.vel.value = '20';
                els.lat.value = TUNGUSKA.lat.toFixed(4);
                els.lng.value = TUNGUSKA.lng.toFixed(4);

                // Update labels and slider fill via existing listeners
                els.angle.dispatchEvent(new Event('input', { bubbles: true }));
                els.vel.dispatchEvent(new Event('input', { bubbles: true }));
                els.diameter.dispatchEvent(new Event('change', { bubbles: true }));
                els.unit.dispatchEvent(new Event('change', { bubbles: true }));
                els.density.dispatchEvent(new Event('change', { bubbles: true }));
                els.lat.dispatchEvent(new Event('change', { bubbles: true }));
                els.lng.dispatchEvent(new Event('change', { bubbles: true }));

                // Recompute speed now that velocity might have changed
                if (typeof recomputeApproachSpeed === 'function') {
                    recomputeApproachSpeed();
                }
                // Start simulation
                resetSimulation();
            }

            // Create the HTML marker element
            function makeTunguskaElement() {
                const wrap = document.createElement('div');
                wrap.className = 'geo-marker';

                const pin = document.createElement('div');
                pin.className = 'gpin';
                wrap.appendChild(pin);

                const card = document.createElement('div');
                card.className = 'gcard';
                card.innerHTML = `
					<div class="gcard-title">Tunguska Event (1908)</div>
					<div class="gcard-body">
						A powerful airburst over Siberia flattened ~2,000 km² of forest.
						Likely a stony asteroid ~50–60 m across entering at high speed.
					</div>
					<button class="gcard-btn" type="button">Simulate this event</button>
				`;
                wrap.appendChild(card);

                // Click handler
                card.querySelector('.gcard-btn')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    runTunguskaSimulation();
                });

                // Keep card visible while hovering
                wrap.addEventListener('mouseenter', () => card.classList.add('show'));
                wrap.addEventListener('mouseleave', () => card.classList.remove('show'));

                return wrap;
            }

            // Attach the htmlElements layer
            world
                .globeMaterial(material)
                .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
                // Crater layer (instant update, no tween)
                .polygonsData([])
                .polygonsTransitionDuration(0)
                .polygonAltitude(d => d.properties?.altitude ?? 0.002)
                .polygonCapColor(d => d.properties?.color ?? 'rgba(255,0,0,0.8)')
                .polygonSideColor(() => 'rgba(0,0,0,0)')
                .polygonStrokeColor(() => 'rgba(0,0,0,0)')
                // Rings layer (shockwave)
                .ringsData([])
                .ringColor(() => (t => `rgba(255,100,50,${Math.sqrt(1 - t)})`))
                .ringMaxRadius('maxR')
                .ringPropagationSpeed('propagationSpeed')
                .ringRepeatPeriod('repeatPeriod')
                // Custom objects layer (asteroid + explosion)
                .objectsData(objects)
                .objectLat('lat')
                .objectLng('lng')
                .objectAltitude('altitude')
                .objectThreeObject(d => {
                    if (d.type === 'asteroid') return asteroidGroup;
                    if (d.type === 'explosion' && explosionGroup) return explosionGroup.group;
                    if (d.type === 'satellite') return satelliteMesh;
                    if (d.type === 'laser') return laserMesh;
                    return undefined;
                })
                // ADD: HTML elements layer for Tunguska marker
                .htmlElementsData([TUNGUSKA])
                .htmlElement(() => makeTunguskaElement())
                .htmlAltitude(() => 0.01) // slightly above surface
                // Keep globeRotation uniform in sync when user interacts
                .onZoom(({ lng, lat }) => material.uniforms.globeRotation.value.set(lng, lat));

            // Mouse event handlers for satellite interaction
            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            function onMouseDown(event) {
                isMouseDown = true;
                checkSatelliteClick();
            }

            function onMouseUp(event) {
                isMouseDown = false;
                isLaserActive = false;
                laserMesh.visible = false;
            }

            function checkSatelliteClick() {
                raycaster.setFromCamera(mouse, world.camera());
                
                // Get satellite position in 3D space
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                
                // Check if click is near satellite (simplified check)
                const satScreenPos = satPos.clone().project(world.camera());
                const distance = Math.sqrt(
                    Math.pow(mouse.x - satScreenPos.x, 2) + 
                    Math.pow(mouse.y - satScreenPos.y, 2)
                );
                
                if (distance < 0.1) { // Click threshold
                    isLaserActive = true;
                    fireLaser();
                }
            }

            function findNearestAsteroid() {
                if (!objects.find(obj => obj.type === 'asteroid')) {
                    return null;
                }
                
                const asteroid = objects.find(obj => obj.type === 'asteroid');
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                const astPos = lngLatToVec(asteroid.lng, asteroid.lat).multiplyScalar(asteroid.altitude + 1);
                
                return { position: astPos, object: asteroid };
            }

            function fireLaser() {
                if (!isLaserActive) return;
                
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                let targetPos;
                
                const nearestAsteroid = findNearestAsteroid();
                if (nearestAsteroid) {
                    // Target asteroid
                    targetPos = nearestAsteroid.position;
                } else {
                    // Fire into space (away from Earth)
                    const direction = satPos.clone().normalize();
                    targetPos = satPos.clone().add(direction.multiplyScalar(10));
                }
                
                // Update laser geometry
                const distance = satPos.distanceTo(targetPos);
                const midPoint = satPos.clone().add(targetPos).multiplyScalar(0.5);
                
                laserMesh.scale.set(laserRadius, distance, laserRadius);
                laserMesh.position.copy(midPoint);
                laserMesh.lookAt(targetPos);
                laserMesh.visible = true;
                
                // Apply force to asteroid if hit
                if (nearestAsteroid && !hasImpacted) {
                    const force = laserPower * 0.001;
                    const laserDir = targetPos.clone().sub(satPos).normalize();
                    approachDir.add(laserDir.multiplyScalar(force));
                    approachDir.normalize();
                }
            }

            // Add event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            // Remove mouse event listeners
            // window.addEventListener('mousemove', onMouseMove);
            // window.addEventListener('mousedown', onMouseDown);
            // window.addEventListener('mouseup', onMouseUp);

            // Helper functions for laser system
            function findNearestAsteroid() {
                const asteroidObj = objects.find(obj => obj.type === 'asteroid');
                if (!asteroidObj) {
                    return null;
                }
                
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                const astPos = lngLatToVec(asteroidObj.lng, asteroidObj.lat).multiplyScalar(asteroidObj.altitude + 1);
                
                return { position: astPos, object: asteroidObj };
            }

            function fireLaser() {
                console.log('fireLaser() called');
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                let targetPos;
                
                const nearestAsteroid = findNearestAsteroid();
                if (nearestAsteroid) {
                    // Target asteroid directly
                    targetPos = nearestAsteroid.position;
                    console.log('Laser targeting asteroid at:', nearestAsteroid.object.lat, nearestAsteroid.object.lng);
                } else {
                    // Fire into space (away from Earth)
                    const direction = satPos.clone().normalize();
                    targetPos = satPos.clone().add(direction.multiplyScalar(10));
                    console.log('No asteroid found, firing into space');
                }
                
                // Calculate laser beam properties
                const laserDirection = targetPos.clone().sub(satPos).normalize();
                const distance = satPos.distanceTo(targetPos);
                console.log('Laser distance:', distance, 'Direction:', laserDirection);
                
                // Update laser radius from UI
                const currentLaserRadius = Number(els.laserRadius.value);
                laserMesh.geometry.dispose();
                laserMesh.geometry = new CylinderGeometry(currentLaserRadius, currentLaserRadius, distance, 8);
                
                // Position laser: start at satellite position, extend toward target
                const laserStart = satPos.clone();
                const laserEnd = targetPos.clone();
                const midPoint = laserStart.clone().add(laserEnd).multiplyScalar(0.5);
                
                laserMesh.position.copy(midPoint);
                
                // Rotate laser to point from satellite to asteroid
                // CylinderGeometry has its axis along Y, so we need to align Y-axis with laser direction
                const up = new Vector3(0, 1, 0);
                const quaternion = new Quaternion().setFromUnitVectors(up, laserDirection);
                laserMesh.setRotationFromQuaternion(quaternion);
                
                // Make laser bright red and visible - ensure material exists
                if (laserMesh.material) {
                    if (laserMesh.material.color && typeof laserMesh.material.color.setHex === 'function') {
                        laserMesh.material.color.setHex(0xff0000);
                    }
                    if (laserMesh.material.emissive && typeof laserMesh.material.emissive.setHex === 'function') {
                        laserMesh.material.emissive.setHex(0xff0000);
                    }
                    if (typeof laserMesh.material.emissiveIntensity !== 'undefined') {
                        laserMesh.material.emissiveIntensity = 0.8;
                    }
                    if (typeof laserMesh.material.opacity !== 'undefined') {
                        laserMesh.material.opacity = 0.95;
                    }
                } else {
                    // Recreate material if it doesn't exist
                    laserMesh.material = new MeshBasicMaterial({ 
                        color: 0xff0000, 
                        transparent: true, 
                        opacity: 0.95,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.8
                    });
                }
                laserMesh.visible = true;
                console.log('Laser visible:', laserMesh.visible, 'Position:', laserMesh.position);
                
                // Apply force to asteroid if hit and not impacted yet
                if (nearestAsteroid && !hasImpacted) {
                    const laserPowerValue = Number(els.laserPower.value);
                    const force = laserPowerValue * 0.001;
                    
                    // Modify asteroid trajectory
                    approachDir.add(laserDirection.multiplyScalar(force));
                    approachDir.normalize();
                    
                    console.log('Laser hit! Applying force:', force, 'Power:', laserPowerValue);
                }
                
                // Hide laser after 2 seconds
                setTimeout(() => {
                    laserMesh.visible = false;
                    console.log('Laser hidden after 2 seconds');
                }, 2000);
            }

            // Fire Laser button event listener - moved inside Promise scope
            els.fireLaser.addEventListener('click', () => {
                console.log('Fire Laser button clicked');
                fireLaser();
            });

            // Update laser radius when slider changes - moved inside Promise scope
            els.laserRadius.addEventListener('input', () => {
                laserRadius = Number(els.laserRadius.value);
                // Update laser material properties for better visibility
                if (laserMesh && laserMesh.material) {
                    laserMesh.material.opacity = 0.9;
                    laserMesh.material.emissiveIntensity = 0.5;
                }
                console.log('Laser radius updated to:', laserRadius);
            });

            // Animate asteroid approach and impact + tail flicker + explosion growth
            let hasImpacted = false;
            // const ALTITUDE_DECAY_PER_FRAME = 0.01; // no longer used for motion
            let lastTick = performance.now();
            let satelliteAngle = 90;
            let laserPower = 50;
            let laserDirection = new Vector3(0, 0, 1);

            function animate() {
                const now = performance.now();
                const dt = Math.max(0.001, (now - lastTick) / 1000);
                lastTick = now;

                // Update satellite orbit always
                satelliteAngle += dt * 0.2;
                satellite.lat = 0; // equatorial orbit
                satellite.lng = (satelliteAngle * 180 / Math.PI) % 360; // convert angle to longitude
                if (satellite.lng > 180) satellite.lng -= 360;
                console.log('Satellite position:', satellite.lat, satellite.lng, satellite.altitude);
                world.objectsData(objects);

                // Straight-line approach motion
                if (!hasImpacted) {
                    approachProgress = Math.min(approachLen, approachProgress + approachSpeedRps * dt); // use slider-driven speed
                    const cur = approachStart.clone().add(approachDir.clone().multiplyScalar(approachProgress));
                    const llh = vecToLngLatAlt(cur);
                    asteroid.lat = llh.lat;
                    asteroid.lng = llh.lng;
                    asteroid.altitude = llh.alt;

                    // Tail orientation + flicker
                    const camera = world.controls().object;
                    const camLocal = asteroidGroup.worldToLocal(camera.position.clone());
                    tailPivot.lookAt(camLocal);
                    tailPivot.rotateY(Math.PI);

                    const jitter = () => Math.random();
                    const lenCore = 1.7 + jitter() * 1.2;
                    const radCore = 0.8 + jitter() * 0.25;
                    tailCore.scale.set(radCore, radCore, lenCore);
                    tailMatCore.opacity = 0.85 + jitter() * 0.15;

                    const lenMid = 2.0 + jitter() * 1.6;
                    const radMid = 1.0 + jitter() * 0.35;
                    tailMid.scale.set(radMid, radMid, lenMid);
                    tailMatMid.opacity = 0.7 + jitter() * 0.25;

                    const lenOuter = 2.2 + jitter() * 1.8;
                    const radOuter = 1.2 + jitter() * 0.6;
                    tailOuter.scale.set(radOuter, radOuter, lenOuter);
                    tailMatOuter.opacity = 0.35 + jitter() * 0.2;

                    glowSprite.material.opacity = 0.7 + jitter() * 0.25;
                    const glowS = 5.5 + jitter() * 2.5;
                    glowSprite.scale.set(glowS, glowS, 1);

                    world.objectsData(objects);

                    // Impact when we reach end of the line (no speed-up for shallow angle; just takes longer)
                    if (approachProgress >= approachLen) {
                        hasImpacted = true;

                        applyImpactFromUI();
                        objects.length = 0;
                        objects.push(satellite); // keep satellite
                        blast = computeBlast();
                        explosionDuration = blast.durationMs;

                        const shock = {
                            lng: IMPACT.lng, lat: IMPACT.lat,
                            maxR: blast.shockMaxR,
                            propagationSpeed: blast.shockSpeed,
                            repeatPeriod: 1e9
                        };
                        world.ringsData([shock]);
                        const lifeMs = (shock.maxR / shock.propagationSpeed) * 1000 + blast.shockLifePadMs;
                        setTimeout(() => world.ringsData([]), lifeMs);

                        explosionGroup = createExplosion();
                        const explosionObj = { type: 'explosion', lat: IMPACT.lat, lng: IMPACT.lng, altitude: 0 };
                        objects.push(explosionObj);
                        world.objectsData(objects);
                        explosionStart = Date.now();

                        if (!craterPlaced) {
                            world.polygonsData([]);
                            const bf = blast.blastFactor;
                            const inner = Math.min(10, Math.max(0.6, 1.0 + 2.0 * bf));
                            const outer = Math.min(18, Math.max(inner + 0.8, inner + 3.2 * bf));
                            const craterFeatures = buildCrater(IMPACT, inner, outer);
                            const altMul = Math.min(2.2, 0.9 + 0.4 * bf);
                            for (const f of craterFeatures) {
                                if (f?.properties?.altitude != null) f.properties.altitude *= altMul;
                            }
                            world.polygonsData(craterFeatures);
                            craterPlaced = true;
                        }
                    }
                }

                // Explosion animation + debris update
                if (explosionGroup) {
                    const t = Math.min(1, (Date.now() - explosionStart) / explosionDuration);
                    const easeOut = 1 - Math.pow(1 - t, 3);

                    // Scale by blast factor multipliers
                    const groupScale = 1 + easeOut * (90 * (blast?.groupScaleMul ?? 1));
                    explosionGroup.group.scale.set(groupScale, groupScale, groupScale);

                    if (explosionGroup.debrisContainer) {
                        const inv = 1 / groupScale;
                        explosionGroup.debrisContainer.scale.set(inv, inv, inv);
                    }

                    const fbScale = 1 + easeOut * (120 * (blast?.fireballScaleMul ?? 1));
                    explosionGroup.fireball.scale.set(fbScale, fbScale, fbScale);
                    explosionGroup.fireballMat.opacity = 0.8 * (1 - Math.pow(t, 1.5));

                    // Core flash fade
                    explosionGroup.coreMat.opacity = 0.8 * (1 - t);

                    // Debris particles integration (stronger damping + soft clamp)
                    {
                        const pos = explosionGroup.debrisGeom.attributes.position.array;
                        const vel = explosionGroup.debrisVel;
                        const count = pos.length / 3;
                        const damping = Math.pow(0.94, dt * 60); // was 0.985
                        const maxR = 2.2; // soft radius cap (local units)
                        const maxR2 = maxR * maxR;

                        for (let i = 0; i < count; i++) {
                            const i3 = i * 3;
                            pos[i3 + 0] += vel[i3 + 0] * dt;
                            pos[i3 + 1] += vel[i3 + 1] * dt;
                            pos[i3 + 2] += vel[i3 + 2] * dt;

                            vel[i3 + 0] *= damping;
                            vel[i3 + 1] *= damping;
                            vel[i3 + 2] *= damping;

                            const x = pos[i3 + 0], y = pos[i3 + 1], z = pos[i3 + 2];
                            const r2 = x * x + y * y + z * z;
                            if (r2 > maxR2) {
                                // pull back slightly and reduce velocity
                                pos[i3 + 0] *= 0.98;
                                pos[i3 + 1] *= 0.98;
                                pos[i3 + 2] *= 0.98;
                                vel[i3 + 0] *= 0.85;
                                vel[i3 + 1] *= 0.85;
                                vel[i3 + 2] *= 0.85;
                            }
                        }
                        explosionGroup.debrisGeom.attributes.position.needsUpdate = true;
                        explosionGroup.debrisMat.opacity = 0.9 * (1 - t);
                    }

                    // Shards integration (stronger damping + soft clamp)
                    {
                        const maxR = 2.2;
                        const maxR2 = maxR * maxR;
                        for (const s of explosionGroup.shards) {
                            s.position.addScaledVector(s.userData.vel, dt);
                            s.userData.vel.multiplyScalar(0.94); // was 0.985
                            s.rotation.x += s.userData.rot.x * dt;
                            s.rotation.y += s.userData.rot.y * dt;
                            s.rotation.z += s.userData.rot.z * dt;
                            s.material.opacity = 0.9 * (1 - t);

                            if (s.position.lengthSq() > maxR2) {
                                s.position.multiplyScalar(0.98);
                                s.userData.vel.multiplyScalar(0.85);
                            }
                        }
                    }

                    // Cleanup at end
                    if (t >= 1) {
                        // Remove only explosion, keep satellite
                        objects = objects.filter(obj => obj.type !== 'explosion');
                        world.objectsData(objects);
                        explosionGroup = null;
                    }
                }

                // Remove old laser logic - replaced by fireLaser() function
                // Old laser logic was here but now handled by button click

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        });

        // ADD: UI state, bindings, mapping (moved to top so it's defined before use)
        const ui = {
            diameter: 50,
            unit: 'm',
            density: 3000,
            angleDeg: 45,
            velocityKms: 20,
            lat: 0,
            lng: 0
        };
        const els = {
            diameter: document.getElementById('ui-diameter'),
            unit: document.getElementById('ui-unit'),
            density: document.getElementById('ui-density'),
            angle: document.getElementById('ui-angle'),
            angleOut: document.getElementById('ui-angleOut'),
            vel: document.getElementById('ui-vel'),
            velOut: document.getElementById('ui-velOut'),
            lat: document.getElementById('ui-lat'),
            lng: document.getElementById('ui-lng'),
            simulate: document.getElementById('simulateBtn'),
            laserPower: document.getElementById('laser-power'),
            laserRadius: document.getElementById('laser-radius'),
            laserRadiusOut: document.getElementById('laser-radius-out'),
            fireLaser: document.getElementById('fire-laser')
        };
        const getDiameterMeters = () => {
            const d = Number(els.diameter.value || ui.diameter);
            const u = els.unit.value || ui.unit;
            return u === 'km' ? d * 1000 : d;
        };
        // Replace computeBlast return mapping with a more responsive one
        function computeBlast() {
            const d_m = getDiameterMeters();
            const rho = Number(els.density.value || ui.density);
            const v_kms = Number(els.vel.value || ui.velocityKms);
            const v = v_kms * 1000;
            const theta = (Number(els.angle.value || ui.angleDeg)) * Math.PI / 180;

            // Energy-based size/speed mapping (responsive, no gaps)
            const vol = Math.PI / 6 * Math.pow(d_m, 3);
            const mass = rho * vol;
            const E = 0.5 * mass * v * v;
            const d0 = 1000, rho0 = 2750, v0 = 20000;
            const vol0 = Math.PI / 6 * Math.pow(d0, 3);
            const m0 = rho0 * vol0;
            const E0 = 0.5 * m0 * v0 * v0;

            const coupling = Math.max(0, Math.sin(theta));
            let bf = Math.cbrt(E / E0) * coupling;

            bf = Math.max(0.45, Math.min(2.5, bf)); // keep widened clamp

            // Stronger visual mapping so sliders are obvious
            return {
                blastFactor: bf,
                // Shockwave scales wider and faster
                shockMaxR: Math.min(260, Math.max(70, 120 * bf + 40)),
                shockSpeed: Math.min(120, Math.max(30, 48 * bf + 10)),
                shockLifePadMs: 700,

                // Explosion timing/scales
                durationMs: Math.round(Math.min(3200, Math.max(900, 1400 * bf + 300))),
                groupScaleMul: Math.min(2.8, Math.max(0.6, 1.1 * bf)),
                fireballScaleMul: Math.min(2.8, Math.max(0.6, 1.05 * bf)),

                // Debris velocities
                debrisSpeedMul: Math.min(2.2, Math.max(0.6, 0.95 * bf)),

                // Asteroid visual scale from diameter (more noticeable)
                asteroidScale: Math.min(10, Math.max(0.15, getDiameterMeters() / 700))
            };
        }
        function wireUI() {
            const updateLabels = () => {
                els.angleOut.textContent = `${Number(els.angle.value).toFixed(0)}°`;
                els.velOut.textContent = `${Number(els.vel.value).toFixed(0)} km/s`;
                els.laserRadiusOut.textContent = `${Number(els.laserRadius.value).toFixed(2)}`;
            };
            ['input', 'change'].forEach(evt => {
                els.angle.addEventListener(evt, updateLabels);
                els.vel.addEventListener(evt, updateLabels);
                els.laserRadius.addEventListener(evt, updateLabels);
            });
            
            // Update laser radius event listener moved inside Promise.all() scope
            // where laserRadius and laserMesh are defined
            
            els.diameter.addEventListener('change', () => ui.diameter = Number(els.diameter.value || ui.diameter));
            els.unit.addEventListener('change', () => ui.unit = els.unit.value);
            els.density.addEventListener('change', () => ui.density = Number(els.density.value || ui.density));
            els.angle.addEventListener('input', () => ui.angleDeg = Number(els.angle.value));
            els.vel.addEventListener('input', () => ui.velocityKms = Number(els.vel.value));
            els.lat.addEventListener('change', () => ui.lat = Number(els.lat.value));
            els.lng.addEventListener('change', () => ui.lng = Number(els.lng.value));
            updateLabels();

            // Fire Laser event listener moved inside Promise.all() scope
            // where fireLaser() function is defined

            // Slider filled-track painting with dual-accent gradient fill (not clipped)
            const setRangeFill = el => {
                if (!el) return;
                const min = Number(el.min || 0), max = Number(el.max || 100), val = Number(el.value || min);
                const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                // Left filled part uses a blue→violet gradient; right part uses track bg
                el.style.background = `linear-gradient(90deg, var(--accent), var(--accent-2)) 0 / ${pct}% 100% no-repeat, var(--track-bg)`;
            };

            const initRange = el => {
                setRangeFill(el);
                ['input', 'change'].forEach(evt => el.addEventListener(evt, () => setRangeFill(el)));
            };
            // ...existing initRange calls...
            initRange(els.angle);
            initRange(els.vel);
            initRange(els.laserPower);
            initRange(els.laserRadius);
        }
        wireUI();
        let blast = computeBlast();

        // Tooltip manager (body-level, not clipped by the panel)
        const tipEl = document.createElement('div');
        tipEl.className = 'ui-tooltip';
        document.body.appendChild(tipEl);
        let hideTO = null, anchor = null;

        function placeTooltipAround(el) {
            const pad = 10;
            tipEl.style.left = '-9999px';
            tipEl.style.top = '-9999px';
            tipEl.classList.add('show');
            // measure
            const rect = el.getBoundingClientRect();
            const w = tipEl.offsetWidth;
            const h = tipEl.offsetHeight;
            let left = rect.right + pad;
            let top = rect.top;

            // clamp inside viewport
            const vw = window.innerWidth, vh = window.innerHeight;
            if (left + w + 8 > vw) left = Math.max(8, vw - w - 8);
            if (top + h + 8 > vh) top = Math.max(8, vh - h - 8);
            tipEl.style.left = `${left}px`;
            tipEl.style.top = `${top}px`;
        }

        function showTooltipFrom(el) {
            clearTimeout(hideTO);
            anchor = el;
            const title = el.getAttribute('data-tip-title') || '';
            const body = el.getAttribute('data-tip') || '';
            tipEl.innerHTML = (title ? `<span class="ttl">${title}</span>` : '') + body;
            tipEl.classList.add('show');
            placeTooltipAround(el);
        }

        function scheduleHideTooltip() {
            clearTimeout(hideTO);
            hideTO = setTimeout(() => {
                tipEl.classList.remove('show');
            }, 120);
        }

        // Bind hover on all .info icons
        function initTooltips() {
            const infos = Array.from(document.querySelectorAll('#controls .info'));
            infos.forEach(el => {
                el.addEventListener('mouseenter', () => showTooltipFrom(el));
                el.addEventListener('mouseleave', scheduleHideTooltip);
                el.addEventListener('focus', () => showTooltipFrom(el));
                el.addEventListener('blur', scheduleHideTooltip);
            });
            // Keep tooltip open when hovered
            tipEl.addEventListener('mouseenter', () => clearTimeout(hideTO));
            tipEl.addEventListener('mouseleave', scheduleHideTooltip);

            // Re-position on resize/scroll if visible
            window.addEventListener('resize', () => { if (tipEl.classList.contains('show') && anchor) placeTooltipAround(anchor); });
            window.addEventListener('scroll', () => { if (tipEl.classList.contains('show') && anchor) placeTooltipAround(anchor); });
        }
        initTooltips();

        // Geodesic helpers for approach path
        function destinationPoint(lngDeg, latDeg, bearingDeg, distanceDeg) {
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const φ1 = latDeg * toRad, λ1 = lngDeg * toRad;
            const θ = bearingDeg * toRad;
            const δ = distanceDeg * toRad;

            const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
            const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
            const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * Math.cos(θ);
            const φ2 = Math.asin(sinφ2);
            const y = Math.sin(θ) * sinδ * cosφ1;
            const x = cosδ - sinφ1 * sinφ2;
            const λ2 = λ1 + Math.atan2(y, x);

            const lat = φ2 * toDeg;
            const lng = ((λ2 * toDeg + 540) % 360) - 180;
            return { lng, lat };
        }

        function gcLerp(a, b, t) {
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const ax = Math.cos(a.lat * toRad) * Math.cos(a.lng * toRad);
            const ay = Math.sin(a.lat * toRad);
            const az = Math.cos(a.lat * toRad) * Math.sin(a.lng * toRad);
            const bx = Math.cos(b.lat * toRad) * Math.cos(b.lng * toRad);
            const by = Math.sin(b.lat * toRad);
            const bz = Math.cos(b.lat * toRad) * Math.sin(b.lng * toRad);

            // Slerp on unit sphere
            const dot = Math.max(-1, Math.min(1, ax * bx + ay * by + az * bz));
            const ω = Math.acos(dot);
            if (ω < 1e-6) return { lng: b.lng, lat: b.lat };
            const s1 = Math.sin((1 - t) * ω) / Math.sin(ω);
            const s2 = Math.sin(t * ω) / Math.sin(ω);
            const x = s1 * ax + s2 * bx;
            const y = s1 * ay + s2 * by;
            const z = s1 * az + s2 * bz;

            const lat = Math.asin(y) * toDeg;
            const lng = Math.atan2(z, x) * toDeg;
            return { lng, lat };
        }
    </script>
</body>