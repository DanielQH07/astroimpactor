<head>
    <link rel="stylesheet" href="style.css" />

    <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
    <!--  <script src="../../dist/globe.gl.js"></script>-->
</head>

<body>
    <!-- Controls Sidebar -->
    <div id="controls">
        <h3>Asteroid Defense System</h3>
        
        <div id="game-status" class="game-status">
            <div class="status-box ready">
                <div class="status-label">STATUS</div>
                <div id="status-value">READY</div>
            </div>
        </div>
        
        <div class="game-progress">
            <div class="label">Deflection Progress</div>
            <div class="progress-bar">
                <div id="deflection-progress" class="progress-fill" style="width: 0%;">0%</div>
            </div>
        </div>

        <div class="label">
            Asteroid Properties
            <span class="info" data-tip-title="Asteroid Properties"
                data-tip="Properties of the incoming asteroid that affect how much laser power is needed to deflect it."></span>
        </div>
        
        <div class="row">
            <label>Diameter</label>
            <input id="ui-diameter" type="number" min="500" max="5000" step="100" value="2300" />
            <span>m</span>
        </div>

        <div class="row">
            <label>Density</label>
            <input id="ui-density" type="number" min="1000" max="5000" step="50" value="2750" />
            <span>kg/m³</span>
        </div>

        <button id="simulateBtn" class="primary-btn">Start Simulation</button>

        <hr>

        <div class="label">
            Laser Controls
            <span class="info" data-tip-title="Laser Controls"
                data-tip="Configure the satellite's laser power and radius. Higher power levels will deflect the asteroid more but require more energy to recharge."></span>
        </div>
        
        <div class="row">
            <label>Power Level</label>
            <input id="laser-power" type="range" min="10" max="100" value="50" class="full" />
            <span id="laser-power-out">50%</span>
        </div>
        
        <div class="row">
            <label>Beam Width</label>
            <input id="laser-radius" type="range" min="0.05" max="0.3" value="0.15" step="0.01" class="full" />
            <span id="laser-radius-out">0.15</span>
        </div>

        <div id="laser-stats" class="laser-stats">
            <div class="stat-row">
                <div class="stat-label">Force</div>
                <div id="force-value" class="stat-value">0 N</div>
            </div>
            <div class="stat-row">
                <div class="stat-label">Deflection</div>
                <div id="deflection-value" class="stat-value">0°</div>
            </div>
        </div>

        <button id="fire-laser" class="action-btn">FIRE LASER</button>
        <button id="reset-simulation" class="secondary-btn" style="display: none;">Reset Simulation</button>
    </div>
    
    <!-- Game messages display -->
    <div id="game-message" class="game-message">
        Welcome to Asteroid Defense System. Configure laser and press Start Simulation.
    </div>

    <div id="globeViz"></div>
    <div id="time"></div>
    </div>

    <div id="globeViz"></div>
    <div id="time"></div>

    <script type="module">
        import {
            BoxGeometry, MeshStandardMaterial, Mesh, MeshBasicMaterial,
            TextureLoader, ShaderMaterial, Vector2, Vector3,
            IcosahedronGeometry, ConeGeometry, SphereGeometry, Group,
            CanvasTexture, SpriteMaterial, AdditiveBlending, Sprite,
            BufferGeometry, Float32BufferAttribute, PointsMaterial, Points,
            TetrahedronGeometry, LineBasicMaterial, LineLoop, Line, CylinderGeometry,
            TubeGeometry, CatmullRomCurve3, Raycaster, Quaternion
        } from 'https://esm.sh/three';
        import { GLTFLoader } from 'https://esm.sh/three/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://esm.sh/three/examples/jsm/loaders/DRACOLoader.js';
        import * as solar from 'https://esm.sh/solar-calculator';
        import { 
            initializeDefenseSystem, 
            createLaserImpact, 
            registerLaserHit, 
            resetGameState,
            getGameState, 
            calculateDeflection,
            createGameAlert
        } from './visual.js';

        // Game state variables
        let gameActive = false;
        let asteroidDeflected = false;
        let simulationRunning = false;
        let asteroidMoving = false;
        let laserReady = true;
        let laserCooldown = 0;
        let laserBeam = null;
        let currentLaserPower = 50;
        let deflectionProgress = 0;

        // Notification system
        function showNotification(title, message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            });

            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            
            notification.innerHTML = `
                <button class="close-btn">&times;</button>
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;

            document.body.appendChild(notification);

            // Show notification with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Auto hide after duration
            const autoHideTimer = setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, duration);

            // Close button functionality
            const closeBtn = notification.querySelector('.close-btn');
            closeBtn.addEventListener('click', () => {
                clearTimeout(autoHideTimer);
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            });

            return notification;
        }

            // Impact location and asteroid object
            const IMPACT = { lat: 0, lng: 0 }; // change as desired
            let objects = [];
            const asteroid = { type: 'asteroid', lat: IMPACT.lat, lng: IMPACT.lng, altitude: 3.0 };
            objects.push(asteroid);
            
            // Animation state variables
            let hasImpacted = false;
            let satellite; // Will be initialized when GLTF loads
            
            // Approach trajectory variables
            let approachStart = null;   // THREE.Vector3
            let approachEnd = null;     // THREE.Vector3
            let approachDir = null;     // THREE.Vector3 (unit)
            let approachLen = 0;        // scalar
            let approachProgress = 0;   // distance traveled along the line
            
            // Trajectory visualization variables (will be initialized later)
            let trajectoryGeom, trajectoryMat, trajectoryLine;
            let trajectoryGlowGeom, trajectoryGlowMat, trajectoryGlow;
            
            // Legacy asteroid path visualization variables (will be replaced by new system)
            let asteroidPathGeom, asteroidPathMat, asteroidPathLine;
            let testLines = [];  // Store test lines for debugging
            
            // New system managers
            let asteroidTracker;
            let trajectoryManager; 
            let debugPanel;

        // Global helper function to convert lng/lat to 3D vector
        function lngLatToVec(lngDeg, latDeg) {
            const toRad = Math.PI / 180;
            const φ = latDeg * toRad, λ = lngDeg * toRad;
            return new Vector3(
                Math.cos(φ) * Math.cos(λ),
                Math.sin(φ),
                Math.cos(φ) * Math.sin(λ)
            );
        }

        // Global helper function to convert 3D vector to lng/lat/alt
        function vecToLngLatAlt(v) {
            const toDeg = 180 / Math.PI;
            const R = 1; // globe radius
            const r = v.length();
            const p = v.clone().divideScalar(r);
            const lat = Math.asin(p.y) * toDeg;
            const lng = Math.atan2(p.z, p.x) * toDeg;
            const alt = r - R;
            return { lng, lat, alt };
        }

        // Function to update trajectory visualization
        function updateTrajectoryVisualization() {
            // Check if trajectory system is initialized
            if (!trajectoryLine || !trajectoryGlow) {
                return;
            }
            
            const asteroidObj = objects.find(obj => obj.type === 'asteroid');
            if (!asteroidObj || hasImpacted || typeof approachDir === 'undefined' || !approachDir) {
                trajectoryLine.visible = false;
                trajectoryGlow.visible = false;
                return;
            }

            const currentPos = lngLatToVec(asteroidObj.lng, asteroidObj.lat).multiplyScalar(asteroidObj.altitude + 1);
            const direction = approachDir.clone().normalize();
            
            // Calculate trajectory for next 50 units ahead (or until it reaches far distance)
            const trajectoryLength = 50;
            const endPos = currentPos.clone().add(direction.clone().multiplyScalar(trajectoryLength));
            
            // Create line points
            const points = [];
            const segments = 50;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = currentPos.clone().lerp(endPos, t);
                points.push(point.x, point.y, point.z);
            }
            
            // Update trajectory line geometry
            const positionArray = new Float32BufferAttribute(points, 3);
            trajectoryGeom.setAttribute('position', positionArray);
            trajectoryGeom.computeBoundingSphere();
            
            // Update glow effect with same geometry
            trajectoryGlowGeom.setAttribute('position', positionArray.clone());
            trajectoryGlowGeom.computeBoundingSphere();
            
            // Show trajectory lines
            trajectoryLine.visible = true;
            trajectoryGlow.visible = true;
            
            // Change color based on whether asteroid will hit Earth
            const willHitEarth = checkIfTrajectoryHitsEarth(currentPos, direction);
            if (willHitEarth) {
                trajectoryMat.color.setHex(0xff4444); // Red for danger
                trajectoryGlowMat.color.setHex(0xff4444);
            } else {
                trajectoryMat.color.setHex(0x44ff44); // Green for safe
                trajectoryGlowMat.color.setHex(0x44ff44);
            }
        }

        // Helper function to check if trajectory will hit Earth
        function checkIfTrajectoryHitsEarth(startPos, direction) {
            // Sample points along trajectory and check distance to Earth center
            const samples = 20;
            const checkDistance = 30; // Check next 30 units
            
            for (let i = 1; i <= samples; i++) {
                const t = (i / samples) * checkDistance;
                const testPos = startPos.clone().add(direction.clone().multiplyScalar(t));
                const distanceToEarth = testPos.length();
                
                // If any point gets too close to Earth surface
                if (distanceToEarth < 1.1) { // Earth radius + small buffer
                    return true;
                }
            }
            return false;
        }

        // Function to update asteroid path with enhanced visualization
        function updateAsteroidPath() {
            console.log('updateAsteroidPath called - using enhanced trajectory visualization');
            
            const asteroidObj = objects.find(obj => obj.type === 'asteroid');
            if (asteroidObj) {
                // Update the trajectory visualization with current asteroid data
                updateAsteroidTrajectory(
                    asteroidObj, 
                    approachDir.clone().normalize(), 
                    asteroidObj.deflected || false
                );
            }
        }

        const dayNightShader = {
            vertexShader: `
	varying vec3 vNormal;
	varying vec2 vUv;
	void main() {
	  vNormal = normalize(normalMatrix * normal);
	  vUv = uv;
	  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
  `,
            fragmentShader: `
	#define PI 3.141592653589793
	uniform sampler2D dayTexture;
	uniform sampler2D nightTexture;
	uniform vec2 sunPosition;
	uniform vec2 globeRotation;
	varying vec3 vNormal;
	varying vec2 vUv;

	float toRad(in float a) {
	  return a * PI / 180.0;
	}

	vec3 Polar2Cartesian(in vec2 c) { // [lng, lat]
	  float theta = toRad(90.0 - c.x);
	  float phi = toRad(90.0 - c.y);
	  return vec3( // x,y,z
		sin(phi) * cos(theta),
		cos(phi),
		sin(phi) * sin(theta)
	  );
	}

	void main() {
	  float invLon = toRad(globeRotation.x);
	  float invLat = -toRad(globeRotation.y);
	  mat3 rotX = mat3(
		1, 0, 0,
		0, cos(invLat), -sin(invLat),
		0, sin(invLat), cos(invLat)
	  );
	  mat3 rotY = mat3(
		cos(invLon), 0, sin(invLon),
		0, 1, 0,
		-sin(invLon), 0, cos(invLon)
	  );
	  vec3 rotatedSunDirection = rotX * rotY * Polar2Cartesian(sunPosition);
	  float intensity = dot(normalize(vNormal), normalize(rotatedSunDirection));
	  vec4 dayColor = texture2D(dayTexture, vUv);
	  vec4 nightColor = texture2D(nightTexture, vUv);
	  float blendFactor = smoothstep(-0.1, 0.1, intensity);
	  gl_FragColor = mix(nightColor, dayColor, blendFactor);
	}
  `
        };

        const sunPosAt = dt => {
            const day = new Date(+dt).setUTCHours(0, 0, 0, 0);
            const t = solar.century(dt);
            const longitude = (day - dt) / 864e5 * 360 - 180;
            return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
        };

        // Set fixed UTC time (no continuous change)
        let dt = +new Date(); // now
        const timeEl = document.getElementById('time');
        timeEl.textContent = new Date(dt).toUTCString();

        const world = new Globe(document.getElementById('globeViz'));

        // Build geodesic circle coordinates (lng/lat pairs) around a center
        function circleCoords(lng, lat, radiusDeg, steps = 96) {
            const coords = [];
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const φ1 = lat * toRad, λ1 = lng * toRad;
            const δ = radiusDeg * toRad;
            const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
            const sinδ = Math.sin(δ), cosδ = Math.cos(δ);

            for (let i = 0; i <= steps; i++) {
                const θ = 2 * Math.PI * i / steps;
                const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * Math.cos(θ);
                const φ2 = Math.asin(sinφ2);
                const y = Math.sin(θ) * sinδ * cosφ1;
                const x = cosδ - sinφ1 * sinφ2;
                const λ2 = λ1 + Math.atan2(y, x);
                const lng2 = ((λ2 * toDeg + 540) % 360) - 180;
                const lat2 = φ2 * toDeg;
                coords.push([lng2, lat2]);
            }
            return coords;
        }

        // Geodesic boundary from an angle-dependent radius function
        function radialCoords(lng, lat, angles, rFn) {
            const coords = [];
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const phi1 = lat * toRad, lambda1 = lng * toRad;
            const sinPhi1 = Math.sin(phi1), cosPhi1 = Math.cos(phi1);

            for (let i = 0; i < angles.length; i++) {
                const theta = angles[i];
                let rDeg = Math.max(0.0001, rFn(theta));
                const delta = rDeg * toRad;
                const sinDelta = Math.sin(delta), cosDelta = Math.cos(delta);

                const sinPhi2 = sinPhi1 + cosPhi1 * sinDelta * Math.cos(theta) * 0 + (sinPhi1 * (cosDelta - 1)); // stabilize
                const phi2 = Math.asin(sinPhi1 * cosDelta + cosPhi1 * sinDelta * Math.cos(theta));

                const y = Math.sin(theta) * sinDelta * cosPhi1;
                const x = cosDelta - sinPhi1 * Math.sin(phi2);
                const lambda2 = lambda1 + Math.atan2(y, x);

                const lng2 = ((lambda2 * toDeg + 540) % 360) - 180;
                const lat2 = phi2 * toDeg;
                coords.push([lng2, lat2]);
            }
            return coords;
        }

        // Irregular, spiky crater with gradient bands (replaces previous buildCrater)
        function buildCrater(center, innerRadiusDeg = 1.2, outerRadiusDeg = 2.1) {
            const steps = 192;
            const angles = Array.from({ length: steps + 1 }, (_, i) => 2 * Math.PI * i / steps);

            // Shape controls
            const phase1 = Math.random() * Math.PI * 2;
            const phase2 = Math.random() * Math.PI * 2;
            const phase3 = Math.random() * Math.PI * 2;

            // Elliptical bias (overall non-roundness)
            const ellipseAngle = Math.random() * Math.PI * 2;
            const ellipseAmpDeg = 0.22; // deg

            // Localized outward spikes (ejecta-like rays)
            const spikeCount = 8;
            const spikes = Array.from({ length: spikeCount }, () => ({
                theta: Math.random() * Math.PI * 2,
                amp: 0.22 + Math.random() * 0.25 // deg
            }));
            const spikeSigma = 0.09;

            const wrap = a => Math.atan2(Math.sin(a), Math.cos(a));
            const spikeBoost = theta => {
                let s = 0;
                for (const sp of spikes) {
                    const d = wrap(theta - sp.theta);
                    s += sp.amp * Math.exp(-0.5 * (d / spikeSigma) * (d / spikeSigma));
                }
                return s;
            };

            // Base noise (multi-harmonic)
            const baseNoise = theta =>
                0.16 * Math.sin(3 * theta + phase1) +
                0.09 * Math.sin(5 * theta + phase2) +
                0.05 * Math.sin(9 * theta + phase3);

            // Bias in degrees at angle theta
            const biasDeg = theta =>
                ellipseAmpDeg * Math.cos(theta - ellipseAngle) +
                baseNoise(theta) +
                spikeBoost(theta);

            // Helper: coords for a given base radius with amplitude scaling
            const coordsFor = (rBaseDeg, ampScale) =>
                radialCoords(center.lng, center.lat, angles, th => rBaseDeg + ampScale * biasDeg(th));

            const features = [];
            const bands = 24;
            const total = outerRadiusDeg - innerRadiusDeg;
            const dr = total / bands;

            // Center disk (irregular but mild)
            const centerAmp = 0.4; // lower jaggedness at core
            let innerCoords = coordsFor(innerRadiusDeg, centerAmp);
            features.push({
                type: 'Feature',
                properties: { kind: 'band', color: 'rgba(255,0,0,0.9)', altitude: 0.003 },
                geometry: { type: 'Polygon', coordinates: [innerCoords] }
            });

            // Concentric irregular annuli with increasing jaggedness and spikes
            for (let i = 0; i < bands; i++) {
                const r1Base = innerRadiusDeg + (i + 1) * dr;
                const t = (r1Base - innerRadiusDeg) / total; // 0..1 from core to rim
                const ampScale = 0.5 + 0.7 * t; // more jagged outward

                const outerCoords = coordsFor(r1Base, ampScale);

                // Color gradient red -> orange with slight transparency drop
                const g = Math.round(140 * t);
                const a = 0.9 + (0.65 - 0.9) * t;
                const color = `rgba(255,${g},0,${a})`;

                features.push({
                    type: 'Feature',
                    properties: { kind: 'band', color, altitude: 0.002 + i * 0.00002 },
                    geometry: { type: 'Polygon', coordinates: [outerCoords, innerCoords.slice().reverse()] }
                });

                // Next band starts at this outer boundary
                innerCoords = outerCoords;
            }

            return features;
        }

        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        gltfLoader.setDRACOLoader(dracoLoader);

        Promise.all([
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg'),
            gltfLoader.loadAsync('aurab.glb')
        ]).then(([dayTexture, nightTexture, satelliteGltf]) => {
            console.log('Satellite GLTF loaded:', satelliteGltf);
            const material = new ShaderMaterial({
                uniforms: {
                    dayTexture: { value: dayTexture },
                    nightTexture: { value: nightTexture },
                    sunPosition: { value: new Vector2() },
                    globeRotation: { value: new Vector2() }
                },
                vertexShader: dayNightShader.vertexShader,
                fragmentShader: dayNightShader.fragmentShader
            });

            // Compute sun position once for current UTC
            const sunNow = sunPosAt(dt);
            material.uniforms.sunPosition.value.set(...sunNow);

            // Shockwave ring config
            const colorInterpolator = t => `rgba(255,100,50,${Math.sqrt(1 - t)})`;

            // Build irregular asteroid mesh
            const rockGeom = new IcosahedronGeometry(1.2, 1);
            const pos = rockGeom.attributes.position;
            const tmp = new Vector3();
            for (let i = 0; i < pos.count; i++) {
                tmp.fromBufferAttribute(pos, i)
                    .normalize()
                    .multiplyScalar(1.1 + Math.random() * 0.7); // jagged
                pos.setXYZ(i, tmp.x, tmp.y, tmp.z);
            }
            rockGeom.computeVertexNormals();
            const rockMat = new MeshStandardMaterial({
                color: 0x666666,
                roughness: 1,
                metalness: 0.05,
                emissive: 0x442200,
                emissiveIntensity: 0.8
            });
            const rockMesh = new Mesh(rockGeom, rockMat);

            // Fiery tail layers
            const tailHeightMid = 6;
            const tailRadiusMid = 1.5;
            const tailGeomMid = new ConeGeometry(tailRadiusMid, tailHeightMid, 20, 1, true);
            tailGeomMid.translate(0, tailHeightMid / 2, 0);
            const tailMatMid = new MeshBasicMaterial({
                color: 0xff7a00,
                transparent: true,
                opacity: 0.8,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailMid = new Mesh(tailGeomMid, tailMatMid);

            // Inner white-hot core
            const tailHeightCore = 4.2;
            const tailRadiusCore = 0.9;
            const tailGeomCore = new ConeGeometry(tailRadiusCore, tailHeightCore, 18, 1, true);
            tailGeomCore.translate(0, tailHeightCore / 2, 0);
            const tailMatCore = new MeshBasicMaterial({
                color: 0xffffcc,
                transparent: true,
                opacity: 0.95,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailCore = new Mesh(tailGeomCore, tailMatCore);

            // Outer red haze
            const tailHeightOuter = 7.5;
            const tailRadiusOuter = 2.2;
            const tailGeomOuter = new ConeGeometry(tailRadiusOuter, tailHeightOuter, 16, 1, true);
            tailGeomOuter.translate(0, tailHeightOuter / 2, 0);
            const tailMatOuter = new MeshBasicMaterial({
                color: 0xff2200,
                transparent: true,
                opacity: 0.45,
                blending: AdditiveBlending,
                depthWrite: false
            });
            const tailOuter = new Mesh(tailGeomOuter, tailMatOuter);

            // Small radial glow sprite at the base
            function makeGlowSprite(size = 64, inner = 'rgba(255,255,200,1)', outer = 'rgba(255,120,0,0)') {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                g.addColorStop(0, inner);
                g.addColorStop(1, outer);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size, size);
                const tex = new CanvasTexture(canvas);
                const mat = new SpriteMaterial({ map: tex, transparent: true, blending: AdditiveBlending, depthWrite: false, opacity: 0.8 });
                const spr = new Sprite(mat);
                spr.scale.set(6, 6, 1);
                return spr;
            }
            const glowSprite = makeGlowSprite();

            // Group asteroid body + tail (via pivot for camera-relative orientation)
            const asteroidGroup = new Group();
            asteroidGroup.add(rockMesh);
            // asteroidGroup.add(tailMesh); // replaced by tailPivot to control orientation
            const tailPivot = new Group();
            // Align cone axis (+Y) to +Z so we can stretch along Z for length
            tailCore.rotation.x = Math.PI / 2;
            tailMid.rotation.x = Math.PI / 2;
            tailOuter.rotation.x = Math.PI / 2;
            glowSprite.position.z = 0.6; // just behind the rock

            tailPivot.add(tailOuter);
            tailPivot.add(tailMid);
            tailPivot.add(tailCore);
            tailPivot.add(glowSprite);
            asteroidGroup.add(tailPivot);

            // Satellite
            satelliteGltf.scene.scale.set(1, 1, 1); // adjust scale as needed
            const satelliteMesh = satelliteGltf.scene;
            satellite = { type: 'satellite', lat: 0, lng: 0, altitude: 1.1, object: satelliteMesh };
            objects.push(satellite);

            // Laser system
            let laserRadius = 0.15; // Increased from 0.05 to 0.15 for better visibility
            const laserGeom = new CylinderGeometry(laserRadius, laserRadius, 1, 8);
            const laserMat = new MeshStandardMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.9,
                emissive: 0xff0000,
                emissiveIntensity: 0.7
            });
            const laserMesh = new Mesh(laserGeom, laserMat);
            laserMesh.visible = false;
            world.scene().add(laserMesh);

            // Initialize trajectory visualization
            trajectoryGeom = new BufferGeometry();
            trajectoryMat = new LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 3
            });
            trajectoryLine = new Line(trajectoryGeom, trajectoryMat);
            trajectoryLine.visible = false;
            world.scene().add(trajectoryLine);

            // Add a glowing effect for trajectory line
            trajectoryGlowGeom = new BufferGeometry();
            trajectoryGlowMat = new LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.3,
                linewidth: 6
            });
            trajectoryGlow = new Line(trajectoryGlowGeom, trajectoryGlowMat);
            trajectoryGlow.visible = false;
            world.scene().add(trajectoryGlow);

            // Initialize enhanced trajectory visualization system
            console.log('Initializing enhanced trajectory visualization system...');
            
            // Create trajectory line using the imported system from visual.js
            createAsteroidTrajectory(world.scene());
            
                // Set up periodic trajectory updates with the new enhanced system
            setInterval(() => {
                const asteroid = objects.find(obj => obj.type === 'asteroid');
                if (asteroid) {
                    // Calculate proper direction vector for realistic trajectory
                    // This gives a better representation of the actual path
                    let effectiveDirection;
                    
                    if (asteroid.deflected) {
                        // For deflected asteroids, use current approach direction
                        effectiveDirection = approachDir.clone();
                    } else {
                        // For non-deflected, add gravity influence for realistic path
                        const asteroidPos = lngLatToVec(asteroid.lng, asteroid.lat).multiplyScalar(asteroid.altitude + 1);
                        const toEarth = new Vector3(0,0,0).sub(asteroidPos).normalize();
                        
                        // Blend the approach direction with gravity pull
                        effectiveDirection = approachDir.clone();
                        effectiveDirection.add(toEarth.multiplyScalar(0.15)); // Subtle gravity influence
                        effectiveDirection.normalize();
                    }
                    
                    // Update trajectory with current asteroid position and calculated direction
                    updateAsteroidTrajectory(
                        asteroid, 
                        effectiveDirection, 
                        asteroid.deflected || false
                    );
                }
            }, 100); // Update very frequently for smoother visualization            console.log('Enhanced trajectory visualization system initialized');
            
            // Test: Add multiple test lines to verify line rendering works
            
            // Test line 1: Simple line from center outward (RED)
            const testGeom1 = new BufferGeometry();
            const testPoints1 = [
                0, 0, 0,      // Center
                5, 0, 0       // X-axis
            ];
            testGeom1.setAttribute('position', new Float32BufferAttribute(testPoints1, 3));
            const testMat1 = new LineBasicMaterial({ color: 0xff0000, linewidth: 5 });
            const testLine1 = new Line(testGeom1, testMat1);
            world.scene().add(testLine1);
            testLines.push(testLine1);
            
            // Test line 2: Around Earth orbit (GREEN)
            const testGeom2 = new BufferGeometry();
            const testPoints2 = [];
            for (let i = 0; i <= 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                testPoints2.push(
                    Math.cos(angle) * 2,  // Orbit at radius 2
                    0,
                    Math.sin(angle) * 2
                );
            }
            testGeom2.setAttribute('position', new Float32BufferAttribute(testPoints2, 3));
            const testMat2 = new LineBasicMaterial({ color: 0x00ff00, linewidth: 5 });
            const testLine2 = new Line(testGeom2, testMat2);
            world.scene().add(testLine2);
            testLines.push(testLine2);
            
            // Test line 3: Diagonal line (BLUE)
            const testGeom3 = new BufferGeometry();
            const testPoints3 = [
                -3, -3, -3,
                3, 3, 3
            ];
            testGeom3.setAttribute('position', new Float32BufferAttribute(testPoints3, 3));
            const testMat3 = new LineBasicMaterial({ color: 0x0000ff, linewidth: 5 });
            const testLine3 = new Line(testGeom3, testMat3);
            world.scene().add(testLine3);
            testLines.push(testLine3);
            
            console.log('Test lines added: RED (x-axis), GREEN (orbit), BLUE (diagonal)');
            console.log('Test red line added to scene');

            // Mouse interaction variables
            let isMouseDown = false;
            let isLaserActive = false;
            const raycaster = new Raycaster();
            const mouse = new Vector2();

            // Satellite orbit pre-drawn as custom line
            const orbitPoints = [];
            const numPoints = 360;
            const orbitRadius = 1 + satellite.altitude; // 1 + 1.1 = 2.1
            for (let i = 0; i < numPoints; i++) {
                const lng = (i / numPoints) * 360 - 180;
                const lat = 0; // equatorial orbit
                const vec = lngLatToVec(lng, lat).multiplyScalar(orbitRadius);
                orbitPoints.push(vec);
            }
            // Create a thick orbit line using TubeGeometry for better visibility
            // Create orbit line với thickness nhỏ hơn
            const orbitCurve = new CatmullRomCurve3(orbitPoints, true);
            const orbitGeom = new TubeGeometry(orbitCurve, 360, 0.02, 8, true); // radius 0.02 thay vì 1
            const orbitMat = new MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
            const orbitLine = new Mesh(orbitGeom, orbitMat);
            world.scene().add(orbitLine);
            objects.push(satellite);

            // Scale asteroid initial size
            function applyAsteroidScale() {
                const b = computeBlast();
                asteroidGroup.scale.set(b.asteroidScale, b.asteroidScale, b.asteroidScale);
            }
            applyAsteroidScale();

            // Map UI lat/lng into IMPACT (with clamping)
            function applyImpactFromUI() {
                const toNum = (v, def) => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : def;
                };
                const lat = Math.max(-90, Math.min(90, toNum(els.lat?.value, ui.lat)));
                const lng = Math.max(-180, Math.min(180, toNum(els.lng?.value, ui.lng)));
                IMPACT.lat = lat;
                IMPACT.lng = lng;
            }

            // Replace fixed speed with slider-driven speed
            const R = 1;                // globe radius in world units for conversion
            const BASE_RPS = 0.6, V0_KMS = 20; // 0.6 radii/s at 20 km/s baseline
            let approachSpeedRps = BASE_RPS;
            function recomputeApproachSpeed() {
                const v = Number(els.vel?.value ?? ui.velocityKms); // km/s from UI
                const mul = Math.pow(v / V0_KMS, 0.8);              // responsive but not extreme
                approachSpeedRps = Math.min(2.5, Math.max(0.2, BASE_RPS * mul));
            }

            function setupStraightApproach() {
                // Impact frame
                const n = lngLatToVec(IMPACT.lng, IMPACT.lat).normalize(); // surface normal (up)
                // East direction tangent at impact point
                const east = new Vector3(-Math.sin(IMPACT.lng * Math.PI / 180), 0, Math.cos(IMPACT.lng * Math.PI / 180)).normalize();

                // Angle alpha from horizontal (0=grazing, 90=vertical)
                const alphaDeg = Number(els.angle?.value ?? ui.angleDeg);
                const alpha = Math.max(1, Math.min(89, alphaDeg)) * Math.PI / 180;

                // Approach direction: from west -> towards impact along +east; we come FROM west so direction points towards impact:
                // d points toward the impact along east and downward along normal
                const d = east.clone().multiplyScalar(Math.cos(alpha)).add(n.clone().multiplyScalar(-Math.sin(alpha))).normalize();

                // Line endpoints: start some distance away along -d from the surface point
                const D = 10.0 * R; // Increased from 6.0 to 10.0 - much more time for satellite defense
                approachEnd = n.clone().multiplyScalar(R);              // exactly at surface
                approachStart = approachEnd.clone().add(d.clone().multiplyScalar(-D));
                approachDir = approachEnd.clone().sub(approachStart).normalize();
                approachLen = approachEnd.distanceTo(approachStart);
                approachProgress = 0;

                // Place asteroid at start and reset deflection state
                const cur = approachStart.clone();
                const llh = vecToLngLatAlt(cur);
                asteroid.lat = llh.lat;
                asteroid.lng = llh.lng;
                asteroid.altitude = llh.alt;
                asteroid.deflected = false; // Reset deflection state
                
                // Update asteroid path after all variables are set
                // Remove this call from setupStraightApproach to avoid timing issues
                // if (typeof updateAsteroidPath === 'function') {
                //     updateAsteroidPath();
                // }
            }

            // Initial placement from UI + angle
            applyImpactFromUI();
            setupStraightApproach();
            recomputeApproachSpeed(); // NEW: set initial speed from slider
            
            world.objectsData(objects);
            
            // Update asteroid path after everything is set up
            updateAsteroidPath();

            // Explosion group (built on impact)
            let explosionGroup = null;
            let explosionStart = 0;
            // Slightly shorter duration
            let explosionDuration = 2000; // was const
            // Track crater placement to ensure single-time creation
            let craterPlaced = false;

            // Replace createExplosion: adds debrisContainer, lowers speeds
            function createExplosion() {
                // Core flash
                const coreGeom = new IcosahedronGeometry(0.15, 2);
                const coreMat = new MeshBasicMaterial({
                    color: 0xfff2aa,
                    transparent: true,
                    opacity: 1,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const core = new Mesh(coreGeom, coreMat);

                // Fireball shell
                const fireballGeo = new SphereGeometry(0.32, 20, 16);
                const fireballMat = new MeshBasicMaterial({
                    color: 0xff9922,
                    transparent: true,
                    opacity: 0.75,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const fireball = new Mesh(fireballGeo, fireballMat);

                // Debris particles (Points)
                const particleCount = 320;
                const debrisGeom = new BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const debrisVel = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3 + 0] = (Math.random() - 0.5) * 0.15;
                    positions[i3 + 1] = (Math.random() - 0.5) * 0.15;
                    positions[i3 + 2] = (Math.random() - 0.5) * 0.15;
                    // Lower particle speed
                    const th = Math.random() * Math.PI * 2;
                    const ph = Math.acos(2 * Math.random() - 1);
                    const base = 0.6 + Math.random() * 1.2; // previous low speed
                    const speed = base * (blast?.debrisSpeedMul ?? 1);
                    debrisVel[i3 + 0] = Math.sin(ph) * Math.cos(th) * speed;
                    debrisVel[i3 + 1] = Math.sin(ph) * Math.sin(th) * speed;
                    debrisVel[i3 + 2] = Math.cos(ph) * speed;
                }
                debrisGeom.setAttribute('position', new Float32BufferAttribute(positions, 3));
                const debrisMat = new PointsMaterial({
                    color: 0xffbb66,
                    size: 0.06,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: AdditiveBlending,
                    depthWrite: false
                });
                const debrisPoints = new Points(debrisGeom, debrisMat);

                // Shards (also scaled by debrisSpeedMul)
                const shards = [];
                const shardCount = 24;
                const shardGeo = new TetrahedronGeometry(0.08);
                for (let i = 0; i < shardCount; i++) {
                    const m = new Mesh(
                        shardGeo,
                        new MeshBasicMaterial({
                            color: 0xcc8844,
                            transparent: true,
                            opacity: 0.9,
                            blending: AdditiveBlending,
                            depthWrite: false
                        })
                    );
                    m.position.set((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                    const th = Math.random() * Math.PI * 2;
                    const ph = Math.acos(2 * Math.random() - 1);
                    const base = 0.5 + Math.random() * 1.0;
                    const speed = base * (blast?.debrisSpeedMul ?? 1);
                    m.userData.vel = new Vector3(
                        Math.sin(ph) * Math.cos(th) * speed,
                        Math.sin(ph) * Math.sin(th) * speed,
                        Math.cos(ph) * speed
                    );
                    m.userData.rot = new Vector3(
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6
                    );
                    shards.push(m);
                }

                // Debris container (neutralize group scaling)
                const debrisContainer = new Group();
                debrisContainer.add(debrisPoints);
                shards.forEach(s => debrisContainer.add(s));

                const g = new Group();
                g.add(fireball);
                g.add(core);
                g.add(debrisContainer);

                return {
                    group: g,
                    core, coreMat,
                    fireball, fireballMat,
                    debrisContainer,
                    debrisPoints, debrisGeom, debrisMat, debrisVel,
                    shards
                };
            }

            // Simple reset that re-applies parameters and restarts the fall
            function resetSimulation() {
                console.log('Simulation reset');
                blast = computeBlast();
                applyAsteroidScale();
                applyImpactFromUI();

                // clear visuals
                world.ringsData([]);
                world.polygonsData([]);
                if (explosionGroup) explosionGroup = null;
                
                // Hide trajectory line
                if (trajectoryLine) trajectoryLine.visible = false;
                if (trajectoryGlow) trajectoryGlow.visible = false;
                if (asteroidPathLine) asteroidPathLine.visible = false;
                
                // Reset global tracking variables
                asteroidDeflected = false;

                // Reset straight-line approach
                objects.length = 0;
                setupStraightApproach();
                recomputeApproachSpeed(); // NEW: refresh speed from current slider
                
                // Reset asteroid object completely
                asteroid.deflected = false; // Clear deflection state
                objects.push(asteroid);
                
                // Reset trajectory color to danger (red)
                setTrajectoryColor(0xff0044);
                if (satellite) {
                    objects.push(satellite); // add satellite back if it exists
                    console.log('Satellite added back to objects');
                } else {
                    console.log('Satellite not available to add back');
                }
                console.log('Objects after reset:', objects.map(o => o.type));
                world.objectsData(objects);
                
                // Update asteroid path after objects are ready
                updateAsteroidPath();

                hasImpacted = false;
                craterPlaced = false;
                satelliteAngle = 90; // reset satellite position
            }
            els.simulate.addEventListener('click', resetSimulation);

            // Update approach when changing angle (before impact)
            els.angle.addEventListener('change', () => {
                if (!hasImpacted) {
                    applyImpactFromUI();
                    setupStraightApproach();
                    world.objectsData(objects);
                }
            });

            // NEW: update speed live when Velocity slider changes (before impact)
            els.vel.addEventListener('input', () => {
                if (!hasImpacted) recomputeApproachSpeed();
            });

            // --- Add Tunguska marker (DOM-based popup) ---
            const TUNGUSKA = { lat: 60 + 55 / 60, lng: 101 + 57 / 60, id: 'tunguska' };

            // Helper to fill UI and run the simulation with preset Tunguska params
            function runTunguskaSimulation() {
                // Prefill UI as in your screenshot/baseline
                els.diameter.value = '60';
                els.unit.value = 'm';
                els.density.value = '2750';
                els.angle.value = '45';
                els.vel.value = '20';
                els.lat.value = TUNGUSKA.lat.toFixed(4);
                els.lng.value = TUNGUSKA.lng.toFixed(4);

                // Update labels and slider fill via existing listeners
                els.angle.dispatchEvent(new Event('input', { bubbles: true }));
                els.vel.dispatchEvent(new Event('input', { bubbles: true }));
                els.diameter.dispatchEvent(new Event('change', { bubbles: true }));
                els.unit.dispatchEvent(new Event('change', { bubbles: true }));
                els.density.dispatchEvent(new Event('change', { bubbles: true }));
                els.lat.dispatchEvent(new Event('change', { bubbles: true }));
                els.lng.dispatchEvent(new Event('change', { bubbles: true }));

                // Recompute speed now that velocity might have changed
                if (typeof recomputeApproachSpeed === 'function') {
                    recomputeApproachSpeed();
                }
                // Start simulation
                resetSimulation();
            }

            // Create the HTML marker element
            function makeTunguskaElement() {
                const wrap = document.createElement('div');
                wrap.className = 'geo-marker';

                const pin = document.createElement('div');
                pin.className = 'gpin';
                wrap.appendChild(pin);

                const card = document.createElement('div');
                card.className = 'gcard';
                card.innerHTML = `
					<div class="gcard-title">Tunguska Event (1908)</div>
					<div class="gcard-body">
						A powerful airburst over Siberia flattened ~2,000 km² of forest.
						Likely a stony asteroid ~50–60 m across entering at high speed.
					</div>
					<button class="gcard-btn" type="button">Simulate this event</button>
				`;
                wrap.appendChild(card);

                // Click handler
                card.querySelector('.gcard-btn')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    runTunguskaSimulation();
                });

                // Keep card visible while hovering
                wrap.addEventListener('mouseenter', () => card.classList.add('show'));
                wrap.addEventListener('mouseleave', () => card.classList.remove('show'));

                return wrap;
            }

            // Attach the htmlElements layer
            world
                .globeMaterial(material)
                .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
                // Crater layer (instant update, no tween)
                .polygonsData([])
                .polygonsTransitionDuration(0)
                .polygonAltitude(d => d.properties?.altitude ?? 0.002)
                .polygonCapColor(d => d.properties?.color ?? 'rgba(255,0,0,0.8)')
                .polygonSideColor(() => 'rgba(0,0,0,0)')
                .polygonStrokeColor(() => 'rgba(0,0,0,0)')
                // Rings layer (shockwave)
                .ringsData([])
                .ringColor(() => (t => `rgba(255,100,50,${Math.sqrt(1 - t)})`))
                .ringMaxRadius('maxR')
                .ringPropagationSpeed('propagationSpeed')
                .ringRepeatPeriod('repeatPeriod')
                // Custom objects layer (asteroid + explosion)
                .objectsData(objects)
                .objectLat('lat')
                .objectLng('lng')
                .objectAltitude('altitude')
                .objectThreeObject(d => {
                    if (d.type === 'asteroid') return asteroidGroup;
                    if (d.type === 'explosion' && explosionGroup) return explosionGroup.group;
                    if (d.type === 'satellite') return satelliteMesh;
                    if (d.type === 'laser') return laserMesh;
                    return undefined;
                })
                // ADD: HTML elements layer for Tunguska marker
                .htmlElementsData([TUNGUSKA])
                .htmlElement(() => makeTunguskaElement())
                .htmlAltitude(() => 0.01) // slightly above surface
                // Keep globeRotation uniform in sync when user interacts
                .onZoom(({ lng, lat }) => material.uniforms.globeRotation.value.set(lng, lat));

            // Debug camera and scene information
            setTimeout(() => {
                const camera = world.camera();
                const scene = world.scene();
                console.log('=== CAMERA DEBUG ===');
                console.log('Camera position:', camera.position);
                console.log('Camera rotation:', camera.rotation);
                console.log('Camera up:', camera.up);
                console.log('Camera far:', camera.far);
                console.log('Camera near:', camera.near);
                console.log('=== SCENE DEBUG ===');
                console.log('Scene children count:', scene.children.length);
                console.log('Scene children types:', scene.children.map(child => child.type));
                
                // Look for our test lines in the scene
                const lines = scene.children.filter(child => child.type === 'Line');
                console.log('Lines in scene:', lines.length);
                lines.forEach((line, index) => {
                    console.log(`Line ${index}:`, {
                        visible: line.visible,
                        material: line.material.color.getHex(),
                        geometry: line.geometry,
                        position: line.position,
                        scale: line.scale
                    });
                });
                
                // Set camera to a good position to see test lines
                camera.position.set(0, 0, 8);  // Move camera back to see the scene
                camera.lookAt(0, 0, 0);        // Look at center
                console.log('Camera repositioned to see test lines');
            }, 2000);  // Wait 2 seconds for everything to load

            // Mouse event handlers for satellite interaction
            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            function onMouseDown(event) {
                isMouseDown = true;
                checkSatelliteClick();
            }

            function onMouseUp(event) {
                isMouseDown = false;
                isLaserActive = false;
                laserMesh.visible = false;
            }

            function checkSatelliteClick() {
                raycaster.setFromCamera(mouse, world.camera());
                
                // Get satellite position in 3D space
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                
                // Check if click is near satellite (simplified check)
                const satScreenPos = satPos.clone().project(world.camera());
                const distance = Math.sqrt(
                    Math.pow(mouse.x - satScreenPos.x, 2) + 
                    Math.pow(mouse.y - satScreenPos.y, 2)
                );
                
                if (distance < 0.1) { // Click threshold
                    isLaserActive = true;
                    fireLaser();
                }
            }

            function findNearestAsteroid() {
                if (!objects.find(obj => obj.type === 'asteroid')) {
                    return null;
                }
                
                const asteroid = objects.find(obj => obj.type === 'asteroid');
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                const astPos = lngLatToVec(asteroid.lng, asteroid.lat).multiplyScalar(asteroid.altitude + 1);
                
                return { position: astPos, object: asteroid };
            }

            function fireLaser() {
                if (!isLaserActive) return;
                
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                let targetPos;
                
                const nearestAsteroid = findNearestAsteroid();
                if (nearestAsteroid) {
                    // Target asteroid
                    targetPos = nearestAsteroid.position;
                } else {
                    // Fire into space (away from Earth)
                    const direction = satPos.clone().normalize();
                    targetPos = satPos.clone().add(direction.multiplyScalar(10));
                }
                
                // Update laser geometry
                const distance = satPos.distanceTo(targetPos);
                const midPoint = satPos.clone().add(targetPos).multiplyScalar(0.5);
                
                laserMesh.scale.set(laserRadius, distance, laserRadius);
                laserMesh.position.copy(midPoint);
                laserMesh.lookAt(targetPos);
                laserMesh.visible = true;
                
                // Apply force to asteroid if hit
                if (nearestAsteroid && !hasImpacted) {
                    const force = laserPower * 0.001;
                    const laserDir = targetPos.clone().sub(satPos).normalize();
                    approachDir.add(laserDir.multiplyScalar(force));
                    approachDir.normalize();
                }
            }

            // Add event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            // Remove mouse event listeners
            // window.addEventListener('mousemove', onMouseMove);
            // window.addEventListener('mousedown', onMouseDown);
            // window.addEventListener('mouseup', onMouseUp);

            // Helper functions for laser system
            function findNearestAsteroid() {
                const asteroidObj = objects.find(obj => obj.type === 'asteroid');
                if (!asteroidObj) {
                    return null;
                }
                
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                const astPos = lngLatToVec(asteroidObj.lng, asteroidObj.lat).multiplyScalar(asteroidObj.altitude + 1);
                
                return { position: astPos, object: asteroidObj };
            }

            // Helper function to check line of sight between satellite and asteroid
            function hasLineOfSight(satPos, targetPos) {
                // Check if Earth blocks the laser path
                const direction = targetPos.clone().sub(satPos).normalize();
                const distance = satPos.distanceTo(targetPos);
                
                // Sample points along the laser path
                const samples = 20;
                for (let i = 1; i < samples; i++) {
                    const t = i / samples;
                    const point = satPos.clone().add(direction.clone().multiplyScalar(distance * t));
                    const distanceFromCenter = point.length();
                    
                    // If any point is inside Earth (radius = 1), line of sight is blocked
                    if (distanceFromCenter < 1.02) { // Small buffer for atmosphere
                        return false;
                    }
                }
                return true;
            }

            function fireLaser() {
                console.log('fireLaser() called');
                
                // Check if game is active
                if (!gameActive) {
                    showNotification(
                        '⚠️ System Inactive', 
                        'Start the simulation first!',
                        'warning',
                        2000
                    );
                    return;
                }
                
                // Check if laser is ready (not on cooldown)
                if (!laserReady) {
                    showNotification(
                        '⚡ Recharging', 
                        'Laser system is recharging. Please wait...',
                        'info',
                        2000
                    );
                    return;
                }
                
                // Get satellite position
                const satPos = lngLatToVec(satellite.lng, satellite.lat).multiplyScalar(satellite.altitude + 1);
                let targetPos;
                
                // Find nearest asteroid
                const nearestAsteroid = findNearestAsteroid();
                if (nearestAsteroid) {
                    targetPos = nearestAsteroid.position;
                    
                    // Check line of sight before firing
                    if (!hasLineOfSight(satPos, targetPos)) {
                        console.log('Cannot fire laser: Earth is blocking the path to asteroid');
                        showNotification(
                            '🌍 Laser Blocked!', 
                            'Cannot fire laser - Earth is blocking the path to the asteroid. Move satellite to a better position or wait for orbital alignment.',
                            'warning',
                            4000
                        );
                        return; // Don't fire if Earth blocks the path
                    }
                    
                    console.log('Laser targeting asteroid at:', nearestAsteroid.object.lat, nearestAsteroid.object.lng);
                } else {
                    // Fire into space (away from Earth)
                    const direction = satPos.clone().normalize();
                    targetPos = satPos.clone().add(direction.multiplyScalar(10));
                    console.log('No asteroid found, firing into space');
                }
                
                // Set laser on cooldown
                laserReady = false;
                const laserPowerValue = Number(els.laserPower.value);
                const cooldownTime = 1000 + (laserPowerValue * 40); // Higher power = longer cooldown
                
                // Update button to show cooldown
                els.fireButton.disabled = true;
                els.fireButton.textContent = 'RECHARGING...';
                
                // Calculate laser beam properties
                const laserDirection = targetPos.clone().sub(satPos).normalize();
                const distance = satPos.distanceTo(targetPos);
                console.log('Laser distance:', distance, 'Direction:', laserDirection);
                
                // Update laser radius from UI
                const currentLaserRadius = Number(els.laserRadius.value);
                laserMesh.geometry.dispose();
                laserMesh.geometry = new CylinderGeometry(currentLaserRadius, currentLaserRadius, distance, 8);
                
                // Position laser: start at satellite position, extend toward target
                const laserStart = satPos.clone();
                const laserEnd = targetPos.clone();
                const midPoint = laserStart.clone().add(laserEnd).multiplyScalar(0.5);
                
                laserMesh.position.copy(midPoint);
                
                // Rotate laser to point from satellite to asteroid
                // CylinderGeometry has its axis along Y, so we need to align Y-axis with laser direction
                const up = new Vector3(0, 1, 0);
                const quaternion = new Quaternion().setFromUnitVectors(up, laserDirection);
                laserMesh.setRotationFromQuaternion(quaternion);
                
                // Make laser bright red and visible - ensure material exists
                if (laserMesh.material) {
                    if (laserMesh.material.color && typeof laserMesh.material.color.setHex === 'function') {
                        laserMesh.material.color.setHex(0xff0000);
                    }
                    if (laserMesh.material.emissive && typeof laserMesh.material.emissive.setHex === 'function') {
                        laserMesh.material.emissive.setHex(0xff0000);
                    }
                    if (typeof laserMesh.material.emissiveIntensity !== 'undefined') {
                        laserMesh.material.emissiveIntensity = 0.8;
                    }
                    if (typeof laserMesh.material.opacity !== 'undefined') {
                        laserMesh.material.opacity = 0.95;
                    }
                } else {
                    // Recreate material if it doesn't exist
                    laserMesh.material = new MeshStandardMaterial({ 
                        color: 0xff0000, 
                        transparent: true, 
                        opacity: 0.95,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.8
                    });
                }
                laserMesh.visible = true;
                console.log('Laser visible:', laserMesh.visible, 'Position:', laserMesh.position);
                
                // Apply force to asteroid if hit and not impacted yet
                if (nearestAsteroid && !hasImpacted) {
                    // Create visual impact effect at hit location
                    createLaserImpact(scene, targetPos, laserPowerValue);
                    
                    // Register the hit in the game system
                    const hitResult = registerLaserHit(laserPowerValue);
                    deflectionProgress = hitResult.percent;
                    
                    // Update UI to show deflection progress
                    els.deflectionProgress.style.width = `${deflectionProgress}%`;
                    els.deflectionProgress.textContent = `${deflectionProgress}%`;
                    
                    // Update game message
                    updateGameMessage(hitResult.message);
                    
                    // Check if asteroid is now fully deflected
                    if (hitResult.deflected && !asteroidDeflected) {
                        // Apply final deflection physics
                        const baseForce = laserPowerValue * 0.005; // Stronger final deflection
                        
                        // Calculate deflection direction: perpendicular to current velocity
                        const asteroidPos = lngLatToVec(nearestAsteroid.object.lng, nearestAsteroid.object.lat)
                            .multiplyScalar(nearestAsteroid.object.altitude + 1);
                        const laserDir = laserDirection.clone().normalize();
                        
                        // Apply deflection force in laser direction (realistic physics)
                        const currentVelocity = approachDir.clone().multiplyScalar(approachSpeedRps);
                        const deflectionForce = laserDir.clone().multiplyScalar(baseForce);
                        
                        // Add deflection to current velocity - this creates actual trajectory change
                        const newVelocity = currentVelocity.add(deflectionForce);
                        
                        // Update both direction and speed based on new velocity
                        const newSpeed = newVelocity.length();
                        approachDir = newVelocity.normalize();
                        approachSpeedRps = newSpeed;
                        
                        // Mark that asteroid has been deflected for trajectory change
                        nearestAsteroid.object.deflected = true;
                        asteroidDeflected = true;
                        
                        // Update asteroid path to show new trajectory and change color to green
                        updateAsteroidPath();
                        setTrajectoryColor(0x00ff00); // Green for successful deflection
                        
                        // Force immediate trajectory update for visual feedback
                        const asteroid = objects.find(obj => obj.type === 'asteroid');
                        if (asteroid) {
                            updateAsteroidTrajectory(
                                asteroid, 
                                approachDir.clone().normalize(), 
                                true // Deflected
                            );
                        }
                        
                        // Show success notification
                        showNotification(
                            '🎉 Mission Accomplished!', 
                            'Asteroid successfully deflected from Earth\'s trajectory!',
                            'success',
                            0 // No auto-hide
                        );
                        
                        // Update status
                        els.statusValue.textContent = 'DEFLECTED';
                        els.gameStatus.querySelector('.status-box').className = 'status-box success';
                        
                        // Show reset button
                        els.resetBtn.style.display = 'block';
                        
                        console.log('Asteroid fully deflected! New direction:', approachDir, 'New speed:', approachSpeedRps);
                    }
                    else if (!asteroidDeflected) {
                        // Apply partial deflection physics - subtle change to trajectory
                        const partialForce = laserPowerValue * 0.001; // Small incremental deflection
                        
                        // Apply slight deflection in laser direction
                        const currentVelocity = approachDir.clone().multiplyScalar(approachSpeedRps);
                        const deflectionForce = laserDirection.clone().multiplyScalar(partialForce);
                        
                        // Add small deflection to current velocity
                        const newVelocity = currentVelocity.add(deflectionForce);
                        
                        // Update direction and speed
                        approachDir = newVelocity.normalize();
                        approachSpeedRps = newVelocity.length();
                        
                        // Update asteroid path visualization
                        updateAsteroidPath();
                        
                        // Show hit notification with progress
                        showNotification(
                            '⚡ Laser Hit!', 
                            `Hit confirmed! Deflection progress: ${deflectionProgress}%. Need more hits!`,
                            'success',
                            3000
                        );
                        
                        console.log('Partial deflection applied. Progress:', deflectionProgress + '%');
                    }
                } else if (!nearestAsteroid) {
                    // Missed - no asteroid in range
                    showNotification(
                        '❌ Missed Target', 
                        'No asteroid in range or laser trajectory missed the target.',
                        'warning',
                        2000
                    );
                }
                
                // Hide laser after 2 seconds
                setTimeout(() => {
                    laserMesh.visible = false;
                    console.log('Laser hidden after 2 seconds');
                }, 2000);
                
                // Reset laser cooldown after delay
                setTimeout(() => {
                    laserReady = true;
                    els.fireButton.disabled = false;
                    els.fireButton.textContent = 'FIRE LASER';
                }, cooldownTime);
            }

            // Fire Laser button event listener - moved inside Promise scope
            els.fireLaser.addEventListener('click', () => {
                console.log('Fire Laser button clicked');
                fireLaser();
            });

            // Update laser radius when slider changes - moved inside Promise scope
            els.laserRadius.addEventListener('input', () => {
                laserRadius = Number(els.laserRadius.value);
                // Update laser material properties for better visibility
                if (laserMesh && laserMesh.material) {
                    laserMesh.material.opacity = 0.9;
                    laserMesh.material.emissiveIntensity = 0.5;
                }
                console.log('Laser radius updated to:', laserRadius);
            });

            // Toggle test lines button event listener
            document.getElementById('toggle-test-lines').addEventListener('click', () => {
                console.log('Toggle test lines clicked');
                const visible = testLines[0]?.visible ?? false;
                testLines.forEach((line, index) => {
                    line.visible = !visible;
                    console.log(`Test line ${index} (${line.material.color.getHexString()}) now:`, !visible ? 'VISIBLE' : 'HIDDEN');
                });
                console.log('Test lines now:', !visible ? 'VISIBLE' : 'HIDDEN');
                
                // Also check asteroid path line status
                if (asteroidPathLine) {
                    console.log('Asteroid path line visible:', asteroidPathLine.visible);
                    console.log('Asteroid path line render order:', asteroidPathLine.renderOrder);
                    console.log('Asteroid path line material:', asteroidPathLine.material);
                }
            });

            // Show asteroid path button event listener (legacy - kept for compatibility)
            document.getElementById('show-asteroid-path').addEventListener('click', () => {
                console.log('Show asteroid path clicked - using enhanced trajectory system');
                
                // Use the enhanced trajectory toggle function
                const isVisible = toggleTrajectoryVisibility();
                trajectoryVisible = isVisible;
                console.log('Trajectory visibility toggled:', isVisible);
            });
            
            // New toggle trajectory button with color feedback
            document.getElementById('toggle-trajectory').addEventListener('click', () => {
                console.log('Toggle trajectory button clicked');
                
                // Use the enhanced trajectory toggle function
                const isVisible = toggleTrajectoryVisibility();
                trajectoryVisible = isVisible;
                
                // Update button appearance
                const button = document.getElementById('toggle-trajectory');
                if (isVisible) {
                    button.textContent = 'Hide Trajectory';
                    button.classList.add('active');
                    button.style.backgroundColor = '#00cc44'; // Green for on
                } else {
                    button.textContent = 'Show Trajectory';
                    button.classList.remove('active');
                    button.style.backgroundColor = '#555555'; // Gray for off
                }
                
                console.log('Trajectory visibility toggled:', isVisible);
            });

            // Animate asteroid approach and impact + tail flicker + explosion growth
            // const ALTITUDE_DECAY_PER_FRAME = 0.01; // no longer used for motion
            let lastTick = performance.now();
            let satelliteAngle = 90;
            let laserPower = 50;
            let laserDirection = new Vector3(0, 0, 1);

            function animate() {
                const now = performance.now();
                const dt = Math.max(0.001, (now - lastTick) / 1000);
                lastTick = now;

                // Update satellite orbit always
                if (satellite) {
                    satelliteAngle += dt * 0.2;
                    satellite.lat = 0; // equatorial orbit
                    satellite.lng = (satelliteAngle * 180 / Math.PI) % 360; // convert angle to longitude
                    if (satellite.lng > 180) satellite.lng -= 360;
                } else {
                    console.log('Satellite object not found in animation');
                }
                world.objectsData(objects);

                // Straight-line approach motion
                if (!hasImpacted) {
                    // Check if asteroid has been deflected - use new trajectory calculation
                    const asteroidObj = objects.find(obj => obj.type === 'asteroid');
                    if (asteroidObj && asteroidObj.deflected) {
                        // Use realistic physics trajectory - asteroid continues in deflected direction
                        const currentPos = lngLatToVec(asteroid.lng, asteroid.lat).multiplyScalar(asteroid.altitude + 1);
                        const newPos = currentPos.add(approachDir.clone().multiplyScalar(approachSpeedRps * dt));
                        
                        const llh = vecToLngLatAlt(newPos);
                        asteroid.lat = llh.lat;
                        asteroid.lng = llh.lng;
                        asteroid.altitude = llh.alt;
                        
                        // Check if asteroid is now moving away from Earth and has passed minimum distance
                        const distanceFromEarth = newPos.length();
                        const earthCenter = new Vector3(0, 0, 0);
                        const toEarth = earthCenter.clone().sub(newPos).normalize();
                        const velocityDotToEarth = approachDir.dot(toEarth);
                        
                        // More stringent success conditions: asteroid must be far away AND moving away
                        // AND have passed the closest approach point to Earth
                        const minSuccessDistance = 3.0; // Asteroid must be at least 3 Earth radii away
                        const isMovingAway = velocityDotToEarth < -0.2; // Strong outward velocity
                        const hasClearedEarth = distanceFromEarth > minSuccessDistance;
                        
                        // Additional check: asteroid's closest approach to Earth should be > 1.5 radii
                        // Calculate closest approach by projecting current position onto velocity vector
                        const timeToClosestApproach = -newPos.dot(approachDir) / approachDir.lengthSq();
                        let closestDistance = distanceFromEarth;
                        
                        if (timeToClosestApproach > 0) {
                            // Future closest approach
                            const futurePos = newPos.clone().add(approachDir.clone().multiplyScalar(timeToClosestApproach));
                            closestDistance = futurePos.length();
                        }
                        
                        const safeClosestApproach = closestDistance > 1.3; // Safe miss distance
                        
                        if (isMovingAway && hasClearedEarth && safeClosestApproach) {
                            console.log('Asteroid successfully deflected and moving away from Earth - resetting simulation');
                            showNotification(
                                '🎉 Mission Successful!', 
                                'Asteroid successfully deflected away from Earth! You have saved our planet. The simulation will reset in a moment.',
                                'success',
                                6000
                            );
                            setTimeout(() => resetSimulation(), 3000); // Reset after 3 seconds for better feedback
                        }
                        
                        // Check for impact with Earth surface
                        if (distanceFromEarth <= 1.02) { // Close to Earth surface
                            hasImpacted = true;
                        }
                    } else {
                        // Original straight-line approach (not deflected yet)
                        approachProgress = Math.min(approachLen, approachProgress + approachSpeedRps * dt);
                        const cur = approachStart.clone().add(approachDir.clone().multiplyScalar(approachProgress));
                        const llh = vecToLngLatAlt(cur);
                        asteroid.lat = llh.lat;
                        asteroid.lng = llh.lng;
                        asteroid.altitude = llh.alt;
                        
                        // Check for impact when reaching end of straight line approach
                        if (approachProgress >= approachLen) {
                            hasImpacted = true;
                        }
                    }

                    // Tail orientation + flicker (same for both trajectories)
                    const camera = world.controls().object;
                    const camLocal = asteroidGroup.worldToLocal(camera.position.clone());
                    tailPivot.lookAt(camLocal);
                    tailPivot.rotateY(Math.PI);

                    const jitter = () => Math.random();
                    const lenCore = 1.7 + jitter() * 1.2;
                    const radCore = 0.8 + jitter() * 0.25;
                    tailCore.scale.set(radCore, radCore, lenCore);
                    tailMatCore.opacity = 0.85 + jitter() * 0.15;

                    const lenMid = 2.0 + jitter() * 1.6;
                    const radMid = 1.0 + jitter() * 0.35;
                    tailMid.scale.set(radMid, radMid, lenMid);
                    tailMatMid.opacity = 0.7 + jitter() * 0.25;

                    const lenOuter = 2.2 + jitter() * 1.8;
                    const radOuter = 1.2 + jitter() * 0.6;
                    tailOuter.scale.set(radOuter, radOuter, lenOuter);
                    tailMatOuter.opacity = 0.35 + jitter() * 0.2;

                    glowSprite.material.opacity = 0.7 + jitter() * 0.25;
                    const glowS = 5.5 + jitter() * 2.5;
                    glowSprite.scale.set(glowS, glowS, 1);

                    world.objectsData(objects);

                    // Update trajectory visualization
                    updateTrajectoryVisualization();
                    
                    // Update asteroid path visualization
                    updateAsteroidPath();

                    // Impact processing - only trigger explosion when asteroid hits Earth
                    if (hasImpacted) {
                        showNotification(
                            '💥 Defense Failed!', 
                            'The asteroid has impacted Earth! The defense system was unable to deflect the incoming threat. Better luck next time!',
                            'error',
                            6000
                        );
                        
                        applyImpactFromUI();
                        objects.length = 0;
                        objects.push(satellite); // keep satellite
                        blast = computeBlast();
                        explosionDuration = blast.durationMs;

                        const shock = {
                            lng: IMPACT.lng, lat: IMPACT.lat,
                            maxR: blast.shockMaxR,
                            propagationSpeed: blast.shockSpeed,
                            repeatPeriod: 1e9
                        };
                        world.ringsData([shock]);
                        const lifeMs = (shock.maxR / shock.propagationSpeed) * 1000 + blast.shockLifePadMs;
                        setTimeout(() => world.ringsData([]), lifeMs);

                        explosionGroup = createExplosion();
                        const explosionObj = { type: 'explosion', lat: IMPACT.lat, lng: IMPACT.lng, altitude: 0 };
                        objects.push(explosionObj);
                        world.objectsData(objects);
                        explosionStart = Date.now();

                        if (!craterPlaced) {
                            world.polygonsData([]);
                            const bf = blast.blastFactor;
                            const inner = Math.min(10, Math.max(0.6, 1.0 + 2.0 * bf));
                            const outer = Math.min(18, Math.max(inner + 0.8, inner + 3.2 * bf));
                            const craterFeatures = buildCrater(IMPACT, inner, outer);
                            const altMul = Math.min(2.2, 0.9 + 0.4 * bf);
                            for (const f of craterFeatures) {
                                if (f?.properties?.altitude != null) f.properties.altitude *= altMul;
                            }
                            world.polygonsData(craterFeatures);
                            craterPlaced = true;
                        }
                    }
                }

                // Explosion animation + debris update
                if (explosionGroup) {
                    const t = Math.min(1, (Date.now() - explosionStart) / explosionDuration);
                    const easeOut = 1 - Math.pow(1 - t, 3);

                    // Scale by blast factor multipliers
                    const groupScale = 1 + easeOut * (90 * (blast?.groupScaleMul ?? 1));
                    explosionGroup.group.scale.set(groupScale, groupScale, groupScale);

                    if (explosionGroup.debrisContainer) {
                        const inv = 1 / groupScale;
                        explosionGroup.debrisContainer.scale.set(inv, inv, inv);
                    }

                    const fbScale = 1 + easeOut * (120 * (blast?.fireballScaleMul ?? 1));
                    explosionGroup.fireball.scale.set(fbScale, fbScale, fbScale);
                    explosionGroup.fireballMat.opacity = 0.8 * (1 - Math.pow(t, 1.5));

                    // Core flash fade
                    explosionGroup.coreMat.opacity = 0.8 * (1 - t);

                    // Debris particles integration (stronger damping + soft clamp)
                    {
                        const pos = explosionGroup.debrisGeom.attributes.position.array;
                        const vel = explosionGroup.debrisVel;
                        const count = pos.length / 3;
                        const damping = Math.pow(0.94, dt * 60); // was 0.985
                        const maxR = 2.2; // soft radius cap (local units)
                        const maxR2 = maxR * maxR;

                        for (let i = 0; i < count; i++) {
                            const i3 = i * 3;
                            pos[i3 + 0] += vel[i3 + 0] * dt;
                            pos[i3 + 1] += vel[i3 + 1] * dt;
                            pos[i3 + 2] += vel[i3 + 2] * dt;

                            vel[i3 + 0] *= damping;
                            vel[i3 + 1] *= damping;
                            vel[i3 + 2] *= damping;

                            const x = pos[i3 + 0], y = pos[i3 + 1], z = pos[i3 + 2];
                            const r2 = x * x + y * y + z * z;
                            if (r2 > maxR2) {
                                // pull back slightly and reduce velocity
                                pos[i3 + 0] *= 0.98;
                                pos[i3 + 1] *= 0.98;
                                pos[i3 + 2] *= 0.98;
                                vel[i3 + 0] *= 0.85;
                                vel[i3 + 1] *= 0.85;
                                vel[i3 + 2] *= 0.85;
                            }
                        }
                        explosionGroup.debrisGeom.attributes.position.needsUpdate = true;
                        explosionGroup.debrisMat.opacity = 0.9 * (1 - t);
                    }

                    // Shards integration (stronger damping + soft clamp)
                    {
                        const maxR = 2.2;
                        const maxR2 = maxR * maxR;
                        for (const s of explosionGroup.shards) {
                            s.position.addScaledVector(s.userData.vel, dt);
                            s.userData.vel.multiplyScalar(0.94); // was 0.985
                            s.rotation.x += s.userData.rot.x * dt;
                            s.rotation.y += s.userData.rot.y * dt;
                            s.rotation.z += s.userData.rot.z * dt;
                            s.material.opacity = 0.9 * (1 - t);

                            if (s.position.lengthSq() > maxR2) {
                                s.position.multiplyScalar(0.98);
                                s.userData.vel.multiplyScalar(0.85);
                            }
                        }
                    }

                    // Cleanup at end
                    if (t >= 1) {
                        // Remove only explosion, keep satellite
                        objects = objects.filter(obj => obj.type !== 'explosion');
                        world.objectsData(objects);
                        explosionGroup = null;
                    }
                }

                // Remove old laser logic - replaced by fireLaser() function
                // Old laser logic was here but now handled by button click

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        });

        // ADD: UI state, bindings, mapping (moved to top so it's defined before use)
        const ui = {
            diameter: 50,
            unit: 'm',
            density: 3000,
            angleDeg: 45,
            velocityKms: 20,
            lat: 0,
            lng: 0
        };
        const els = {
            gameMessage: document.getElementById('game-message'),
            fireButton: document.getElementById('fire-laser'),
            simulateBtn: document.getElementById('simulateBtn'),
            resetBtn: document.getElementById('reset-simulation'),
            laserPower: document.getElementById('laser-power'),
            laserPowerOut: document.getElementById('laser-power-out'),
            laserRadius: document.getElementById('laser-radius'),
            laserRadiusOut: document.getElementById('laser-radius-out'),
            statusValue: document.getElementById('status-value'),
            deflectionProgress: document.getElementById('deflection-progress'),
            forceValue: document.getElementById('force-value'),
            deflectionValue: document.getElementById('deflection-value'),
            gameStatus: document.getElementById('game-status'),
            uiDiameter: document.getElementById('ui-diameter'),
            uiDensity: document.getElementById('ui-density'),
            fireLaser: document.getElementById('fire-laser')
        };
        const getDiameterMeters = () => {
            const d = Number(els.diameter.value || ui.diameter);
            const u = els.unit.value || ui.unit;
            return u === 'km' ? d * 1000 : d;
        };
        // Replace computeBlast return mapping with a more responsive one
        function computeBlast() {
            const d_m = getDiameterMeters();
            const rho = Number(els.density.value || ui.density);
            const v_kms = Number(els.vel.value || ui.velocityKms);
            const v = v_kms * 1000;
            const theta = (Number(els.angle.value || ui.angleDeg)) * Math.PI / 180;

            // Energy-based size/speed mapping (responsive, no gaps)
            const vol = Math.PI / 6 * Math.pow(d_m, 3);
            const mass = rho * vol;
            const E = 0.5 * mass * v * v;
            const d0 = 1000, rho0 = 2750, v0 = 20000;
            const vol0 = Math.PI / 6 * Math.pow(d0, 3);
            const m0 = rho0 * vol0;
            const E0 = 0.5 * m0 * v0 * v0;

            const coupling = Math.max(0, Math.sin(theta));
            let bf = Math.cbrt(E / E0) * coupling;

            bf = Math.max(0.45, Math.min(2.5, bf)); // keep widened clamp

            // Stronger visual mapping so sliders are obvious
            return {
                blastFactor: bf,
                // Shockwave scales wider and faster
                shockMaxR: Math.min(260, Math.max(70, 120 * bf + 40)),
                shockSpeed: Math.min(120, Math.max(30, 48 * bf + 10)),
                shockLifePadMs: 700,

                // Explosion timing/scales
                durationMs: Math.round(Math.min(3200, Math.max(900, 1400 * bf + 300))),
                groupScaleMul: Math.min(2.8, Math.max(0.6, 1.1 * bf)),
                fireballScaleMul: Math.min(2.8, Math.max(0.6, 1.05 * bf)),

                // Debris velocities
                debrisSpeedMul: Math.min(2.2, Math.max(0.6, 0.95 * bf)),

                // Asteroid visual scale from diameter (more noticeable)
                asteroidScale: Math.min(10, Math.max(0.15, getDiameterMeters() / 700))
            };
        }
        function wireUI() {
            const updateLabels = () => {
                els.angleOut.textContent = `${Number(els.angle.value).toFixed(0)}°`;
                els.velOut.textContent = `${Number(els.vel.value).toFixed(0)} km/s`;
                els.laserRadiusOut.textContent = `${Number(els.laserRadius.value).toFixed(2)}`;
            };
            ['input', 'change'].forEach(evt => {
                els.angle.addEventListener(evt, updateLabels);
                els.vel.addEventListener(evt, updateLabels);
                els.laserRadius.addEventListener(evt, updateLabels);
            });
            
            // Update laser radius event listener moved inside Promise.all() scope
            // where laserRadius and laserMesh are defined
            
            els.diameter.addEventListener('change', () => ui.diameter = Number(els.diameter.value || ui.diameter));
            els.unit.addEventListener('change', () => ui.unit = els.unit.value);
            els.density.addEventListener('change', () => ui.density = Number(els.density.value || ui.density));
            els.angle.addEventListener('input', () => ui.angleDeg = Number(els.angle.value));
            els.vel.addEventListener('input', () => ui.velocityKms = Number(els.vel.value));
            els.lat.addEventListener('change', () => ui.lat = Number(els.lat.value));
            els.lng.addEventListener('change', () => ui.lng = Number(els.lng.value));
            updateLabels();

            // Fire Laser event listener moved inside Promise.all() scope
            // where fireLaser() function is defined

            // Slider filled-track painting with dual-accent gradient fill (not clipped)
            const setRangeFill = el => {
                if (!el) return;
                const min = Number(el.min || 0), max = Number(el.max || 100), val = Number(el.value || min);
                const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                // Left filled part uses a blue→violet gradient; right part uses track bg
                el.style.background = `linear-gradient(90deg, var(--accent), var(--accent-2)) 0 / ${pct}% 100% no-repeat, var(--track-bg)`;
            };

            const initRange = el => {
                setRangeFill(el);
                ['input', 'change'].forEach(evt => el.addEventListener(evt, () => setRangeFill(el)));
            };
            // ...existing initRange calls...
            initRange(els.angle);
            initRange(els.vel);
            initRange(els.laserPower);
            initRange(els.laserRadius);
        }
        wireUI();
        let blast = computeBlast();

        // Tooltip manager (body-level, not clipped by the panel)
        const tipEl = document.createElement('div');
        tipEl.className = 'ui-tooltip';
        document.body.appendChild(tipEl);
        let hideTO = null, anchor = null;

        function placeTooltipAround(el) {
            const pad = 10;
            tipEl.style.left = '-9999px';
            tipEl.style.top = '-9999px';
            tipEl.classList.add('show');
            // measure
            const rect = el.getBoundingClientRect();
            const w = tipEl.offsetWidth;
            const h = tipEl.offsetHeight;
            let left = rect.right + pad;
            let top = rect.top;

            // clamp inside viewport
            const vw = window.innerWidth, vh = window.innerHeight;
            if (left + w + 8 > vw) left = Math.max(8, vw - w - 8);
            if (top + h + 8 > vh) top = Math.max(8, vh - h - 8);
            tipEl.style.left = `${left}px`;
            tipEl.style.top = `${top}px`;
        }

        function showTooltipFrom(el) {
            clearTimeout(hideTO);
            anchor = el;
            const title = el.getAttribute('data-tip-title') || '';
            const body = el.getAttribute('data-tip') || '';
            tipEl.innerHTML = (title ? `<span class="ttl">${title}</span>` : '') + body;
            tipEl.classList.add('show');
            placeTooltipAround(el);
        }

        function scheduleHideTooltip() {
            clearTimeout(hideTO);
            hideTO = setTimeout(() => {
                tipEl.classList.remove('show');
            }, 120);
        }

        // Bind hover on all .info icons
        function initTooltips() {
            const infos = Array.from(document.querySelectorAll('#controls .info'));
            infos.forEach(el => {
                el.addEventListener('mouseenter', () => showTooltipFrom(el));
                el.addEventListener('mouseleave', scheduleHideTooltip);
                el.addEventListener('focus', () => showTooltipFrom(el));
                el.addEventListener('blur', scheduleHideTooltip);
            });
            // Keep tooltip open when hovered
            tipEl.addEventListener('mouseenter', () => clearTimeout(hideTO));
            tipEl.addEventListener('mouseleave', scheduleHideTooltip);

            // Re-position on resize/scroll if visible
            window.addEventListener('resize', () => { if (tipEl.classList.contains('show') && anchor) placeTooltipAround(anchor); });
            window.addEventListener('scroll', () => { if (tipEl.classList.contains('show') && anchor) placeTooltipAround(anchor); });
        }
        initTooltips();

        // Geodesic helpers for approach path
        function destinationPoint(lngDeg, latDeg, bearingDeg, distanceDeg) {
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const φ1 = latDeg * toRad, λ1 = lngDeg * toRad;
            const θ = bearingDeg * toRad;
            const δ = distanceDeg * toRad;

            const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
            const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
            const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * Math.cos(θ);
            const φ2 = Math.asin(sinφ2);
            const y = Math.sin(θ) * sinδ * cosφ1;
            const x = cosδ - sinφ1 * sinφ2;
            const λ2 = λ1 + Math.atan2(y, x);

            const lat = φ2 * toDeg;
            const lng = ((λ2 * toDeg + 540) % 360) - 180;
            return { lng, lat };
        }

        function gcLerp(a, b, t) {
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const ax = Math.cos(a.lat * toRad) * Math.cos(a.lng * toRad);
            const ay = Math.sin(a.lat * toRad);
            const az = Math.cos(a.lat * toRad) * Math.sin(a.lng * toRad);
            const bx = Math.cos(b.lat * toRad) * Math.cos(b.lng * toRad);
            const by = Math.sin(b.lat * toRad);
            const bz = Math.cos(b.lat * toRad) * Math.sin(b.lng * toRad);

            // Slerp on unit sphere
            const dot = Math.max(-1, Math.min(1, ax * bx + ay * by + az * bz));
            const ω = Math.acos(dot);
            if (ω < 1e-6) return { lng: b.lng, lat: b.lat };
            const s1 = Math.sin((1 - t) * ω) / Math.sin(ω);
            const s2 = Math.sin(t * ω) / Math.sin(ω);
            const x = s1 * ax + s2 * bx;
            const y = s1 * ay + s2 * by;
            const z = s1 * az + s2 * bz;

            const lat = Math.asin(y) * toDeg;
            const lng = Math.atan2(z, x) * toDeg;
            return { lng, lat };
        }
    </script>
</body>