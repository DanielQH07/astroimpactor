<head>
    <style>
        body {
            margin: 0;
        }

        #time {
            position: absolute;
            bottom: 8px;
            left: 8px;
            color: lightblue;
            font-family: monospace;
        }
    </style>

    <!--  <script src="../../dist/globe.gl.js"></script>-->
</head>

<body>
    <div id="globeViz"></div>
    <div id="time"></div>

    <div id="impactForm">
        <h3>üöÄ M√¥ ph·ªèng va ch·∫°m</h3>
        <label>Vƒ© ƒë·ªô (lat): <input id="latInput" type="number" value="10.75"></label>
        <label>Kinh ƒë·ªô (lon): <input id="lonInput" type="number" value="106.67"></label>
        <label>ƒê∆∞·ªùng k√≠nh (m): <input id="diameterInput" type="number" value="500"></label>
        <label>V·∫≠n t·ªëc (m/s): <input id="velocityInput" type="number" value="20000"></label>
        <label>M·∫≠t ƒë·ªô (kg/m¬≥): <input id="densityInput" type="number" value="3000"></label>
        <label>G√≥c va ch·∫°m (¬∞): <input id="angleInput" type="number" value="45"></label>
        <button id="simulateBtn">M√¥ ph·ªèng</button>
    </div>

    <style>
        #impactForm {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-family: monospace;
            padding: 10px;
            border-radius: 8px;
            width: 200px;
        }

        #impactForm h3 {
            font-size: 14px;
            margin-top: 0;
        }

        #impactForm label {
            display: block;
            font-size: 12px;
            margin-top: 6px;
        }

        #impactForm input {
            width: 100%;
            box-sizing: border-box;
            font-size: 12px;
        }

        #impactForm button {
            margin-top: 8px;
            width: 100%;
            background: #ff5722;
            color: #fff;
            border: none;
            padding: 6px;
            cursor: pointer;
        }

        #impactForm button:hover {
            background: #e64a19;
        }
    </style>


    <script type="module">
        import Globe from 'https://esm.sh/globe.gl';
        import {
            TextureLoader, ShaderMaterial, Vector2, MeshPhongMaterial,
            SphereGeometry, MeshBasicMaterial, Mesh, Vector3, SpriteMaterial, Sprite, CanvasTexture
        } from 'https://esm.sh/three';
        import * as solar from 'https://esm.sh/solar-calculator';

        const VELOCITY = 1; // minutes per frame

        // Custom shader:  Blends night and day images to simulate day/night cycle
        const dayNightShader = {
            vertexShader: `
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        #define PI 3.141592653589793
        uniform sampler2D dayTexture;
        uniform sampler2D nightTexture;
        uniform vec2 sunPosition;
        uniform vec2 globeRotation;
        varying vec3 vNormal;
        varying vec2 vUv;

        float toRad(in float a) {
          return a * PI / 180.0;
        }

        vec3 Polar2Cartesian(in vec2 c) { // [lng, lat]
          float theta = toRad(90.0 - c.x);
          float phi = toRad(90.0 - c.y);
          return vec3( // x,y,z
            sin(phi) * cos(theta),
            cos(phi),
            sin(phi) * sin(theta)
          );
        }

        void main() {
          float invLon = toRad(globeRotation.x);
          float invLat = -toRad(globeRotation.y);
          mat3 rotX = mat3(
            1, 0, 0,
            0, cos(invLat), -sin(invLat),
            0, sin(invLat), cos(invLat)
          );
          mat3 rotY = mat3(
            cos(invLon), 0, sin(invLon),
            0, 1, 0,
            -sin(invLon), 0, cos(invLon)
          );
          vec3 rotatedSunDirection = rotX * rotY * Polar2Cartesian(sunPosition);
          float intensity = dot(normalize(vNormal), normalize(rotatedSunDirection));
          vec4 dayColor = texture2D(dayTexture, vUv);
          vec4 nightColor = texture2D(nightTexture, vUv);
          float blendFactor = smoothstep(-0.1, 0.1, intensity);
          gl_FragColor = mix(nightColor, dayColor, blendFactor);
        }
      `
        };

        const sunPosAt = dt => {
            const day = new Date(+dt).setUTCHours(0, 0, 0, 0);
            const t = solar.century(dt);
            const longitude = (day - dt) / 864e5 * 360 - 180;
            return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
        };

        let dt = +new Date();
        const timeEl = document.getElementById('time');

        const world = Globe()(document.getElementById('globeViz'));


        Promise.all([
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
            new TextureLoader().loadAsync('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg')
        ]).then(([dayTexture, nightTexture]) => {
            const material = new ShaderMaterial({
                uniforms: {
                    dayTexture: { value: dayTexture },
                    nightTexture: { value: nightTexture },
                    sunPosition: { value: new Vector2() },
                    globeRotation: { value: new Vector2() }
                },
                vertexShader: dayNightShader.vertexShader,
                fragmentShader: dayNightShader.fragmentShader
            });

            // ===== H√†m t√≠nh to√°n c∆° b·∫£n =====
            // ---- Thay th·∫ø/ghi ƒë√® h√†m simulateImpact c≈© b·∫±ng ƒëo·∫°n sau ----
            function simulateImpact(params) {
                const { diameter, velocity, density, angle, lat, lon, nSamples = 1000 } = params;

                // Helper: c∆° b·∫£n
                const massFromDiameter = d => (Math.PI / 6) * density * Math.pow(d, 3); // kg
                const energyJ = (m, v) => 0.5 * m * v * v;
                const J_TO_MEGATON = 1 / 4.184e15;

                // Collins-ish scaling (gi·ªØ gi·ªëng code g·ªëc, c√≥ th·ªÉ thay b·∫±ng scaling ch√≠nh x√°c h∆°n)
                const craterFromEnergyMt = (energyMt) => {
                    const craterDiameterKm = 1.8 * Math.pow(energyMt, 1 / 3);
                    return craterDiameterKm; // km
                };
                const blastRadiiFromEnergyMt = (energyMt) => {
                    // p10/p5/p1 (km) -- gi·ªØ logic ban ƒë·∫ßu (g·ªëc c√≥ nh√¢n *100 cho p10, gi·ªØ structure)
                    const base10 = 0.28 * Math.pow(energyMt, 1 / 3) * 100;
                    return { p10: base10, p5: base10 * 1.5, p1: base10 * 3 };
                };

                // Simple airburst heuristic (very approximate)
                // dynamic pressure q = 0.5 * rho_air * v^2; if q > strength -> breakup
                // We'll not implement full atmosphere model; instead allow a simple rule:
                // if diameter < 50m and velocity > 11000 m/s -> likely airburst (adjustable)
                const isLikelyAirburst = (d, v) => (d < 50 && v > 11000);

                // Monte Carlo: sample small variations around given params to build impact probability
                const samples = [];
                for (let i = 0; i < nSamples; ++i) {
                    // sample noise: gaussian-like via Box-Muller
                    const gauss = (sigma) => {
                        let u = 0, v = 0;
                        while (u === 0) u = Math.random();
                        while (v === 0) v = Math.random();
                        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                        return z * sigma;
                    };

                    // relative uncertainties: tweak as you like
                    const d_sample = Math.max(0.1, diameter + gauss(0.05 * diameter)); // 5% sigma
                    const v_sample = Math.max(100, velocity + gauss(0.05 * velocity));
                    const rho_sample = Math.max(500, density + gauss(0.1 * density));
                    const angle_sample = Math.max(5, Math.min(90, angle + gauss(5)));

                    const m = massFromDiameter(d_sample);
                    const E = energyJ(m, v_sample);
                    const E_mt = E * J_TO_MEGATON;
                    const crater_km = craterFromEnergyMt(E_mt);
                    const blasts = blastRadiiFromEnergyMt(E_mt);
                    const airburst = isLikelyAirburst(d_sample, v_sample);

                    // for now, we project impact point at same lat/lon with tiny dispersion for sampling
                    // dispersion distance (meters) - tune according to uncertainty (here modest)
                    const dispersion_m = Math.abs(gauss(1000)); // e.g., 1 km sigma
                    const bearing = Math.random() * 2 * Math.PI;
                    // convert meters offset to delta lat/lon (approx)
                    const R = 6371000; // Earth radius m
                    const deltaLat = (dispersion_m * Math.cos(bearing)) / R * (180 / Math.PI);
                    const deltaLon = (dispersion_m * Math.sin(bearing)) / (R * Math.cos(lat * Math.PI / 180)) * (180 / Math.PI);

                    samples.push({
                        lat: lat + deltaLat,
                        lon: lon + deltaLon,
                        diameter: d_sample,
                        velocity: v_sample,
                        density: rho_sample,
                        angle: angle_sample,
                        energyMt: E_mt,
                        crater_km,
                        blasts,
                        airburst
                    });
                }

                // Aggregate: compute central single-run metrics (from nominal params)
                const nominalMass = massFromDiameter(diameter);
                const nominalEnergy = energyJ(nominalMass, velocity);
                const nominalEnergyMt = nominalEnergy * J_TO_MEGATON;
                const nominalCraterKm = craterFromEnergyMt(nominalEnergyMt);
                const nominalBlasts = blastRadiiFromEnergyMt(nominalEnergyMt);

                // --- Visualization updates on globe ---
                // 1) draw nominal rings (as before)
                const impactRings = [
                    { lat, lon, radius: nominalBlasts.p1 * 1000, color: 'rgba(255,0,0,0.25)' },   // ƒë·ªè ƒë·∫≠m
                    { lat, lon, radius: nominalBlasts.p5 * 1000, color: 'rgba(255,165,0,0.18)' }, // cam
                    { lat, lon, radius: nominalBlasts.p10 * 1000, color: 'rgba(255,255,0,0.12)' } // v√†ng nh·∫°t
                ];

                world
                    .ringsData(impactRings)
                    .ringLat(d => d.lat)
                    .ringLng(d => d.lon)
                    .ringColor(d => () => d.color)
                    .ringMaxRadius(d => d.radius)
                    .ringPropagationSpeed(5)
                    .ringRepeatPeriod(3000);

                // 2) add marker at center
                const markerGeo = new SphereGeometry(0.02, 64, 64);
                const markerMat = new MeshPhongMaterial({
                    color: 0xff2200,
                    emissive: 0xff4400,
                    shininess: 120
                });
                const marker = new Mesh(markerGeo, markerMat);

                // L·∫•y vector h∆∞·ªõng t·ª´ t√¢m Tr√°i ƒê·∫•t ƒë·∫øn ƒëi·ªÉm va ch·∫°m
                const coords = world.getCoords(lat, lon, 0);
                const pos = new Vector3(coords.x, coords.y, coords.z);

                // Normalize ƒë·ªÉ marker n·∫±m s√°t b·ªÅ m·∫∑t + nh√¥ ra 1 ch√∫t
                pos.normalize().multiplyScalar(1.01);  // 1 = b√°n k√≠nh Earth, 1.01 = nh√¥ ra ngo√†i

                marker.position.copy(pos);

                world.scene().add(marker);


                // 3) Monte Carlo impact probability visualization (simple): 
                // create many tiny translucent rings/points for each sample (additive blending => hotspots)
                // To avoid adding thousands of heavy 3D meshes to scene, we add batched pointsData for globe
                // Prepare points: small circles encoded as points with size proportional to energy
                const points = samples.map(s => ({
                    lat: s.lat,
                    lng: s.lon,
                    size: Math.max(0.5, Math.log10(Math.max(1e-6, s.energyMt)) + 6), // visual size heuristic
                    color: s.airburst ? 'rgba(255,200,60,0.03)' : 'rgba(255,80,20,0.03)'
                }));

                // If globe supports pointsLayer:
                world.pointsData([{ lat, lng: lon, size: 1, color: 'red' }])
                    .pointLat(d => d.lat)
                    .pointLng(d => d.lng)
                    .pointAltitude(0.01)
                    .pointRadius(d => 0.3)
                    .pointColor(d => d.color);

                // Return summary stats + samples (if caller wants further processing)
                return {
                    nominal: {
                        energyMt: nominalEnergyMt,
                        craterKm: nominalCraterKm,
                        blastRadiusKm: nominalBlasts
                    },
                    samples
                };
            }

            // ===== G√°n s·ª± ki·ªán n√∫t "M√¥ ph·ªèng" =====
            document.getElementById('simulateBtn').addEventListener('click', () => {
                const lat = parseFloat(document.getElementById('latInput').value);
                const lon = parseFloat(document.getElementById('lonInput').value);
                const diameter = parseFloat(document.getElementById('diameterInput').value);
                const velocity = parseFloat(document.getElementById('velocityInput').value);
                const density = parseFloat(document.getElementById('densityInput').value);
                const angle = parseFloat(document.getElementById('angleInput').value);

                const result = simulateImpact({ diameter, velocity, density, angle, lat, lon, nSamples: 1500 });
                console.log('K·∫øt qu·∫£ m√¥ ph·ªèng (t·ªïng qu√°t):', result.nominal);

                // === Impact rings (s√≥ng xung k√≠ch) ===
                const nominalBlasts = result.nominal.blastRadiusKm;
                const impactRings = [
                    { lat, lon, radius: nominalBlasts.p1 * 1000, color: 'rgba(255,0,0,0.25)' },   // ƒë·ªè
                    { lat, lon, radius: nominalBlasts.p5 * 1000, color: 'rgba(255,165,0,0.18)' }, // cam
                    { lat, lon, radius: nominalBlasts.p10 * 1000, color: 'rgba(255,255,0,0.12)' }  // v√†ng
                ];

                world
                    .ringsData(impactRings)
                    .ringLat(d => d.lat)
                    .ringLng(d => d.lon)
                    .ringColor(d => () => d.color)
                    .ringMaxRadius(d => d.radius)
                    .ringPropagationSpeed(5)
                    .ringRepeatPeriod(3000);

                // === Gradient spot v√πng va ch·∫°m tr·ª±c ti·∫øp ===
                function createGradientTexture() {
                    const size = 256;
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;

                    const ctx = canvas.getContext('2d');
                    const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                    gradient.addColorStop(0, 'rgba(255,0,0,0.9)');     // t√¢m ƒë·ªè
                    gradient.addColorStop(0.5, 'rgba(255,140,0,0.6)'); // cam
                    gradient.addColorStop(1, 'rgba(255,220,0,0.3)');   // v√†ng

                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, size, size);

                    return new CanvasTexture(canvas);
                }

                const coords = world.getCoords(lat, lon, 0.01);
                const spriteMat = new SpriteMaterial({
                    map: createGradientTexture(),
                    transparent: true,
                    depthWrite: false
                });

                const sprite = new Sprite(spriteMat);
                sprite.position.set(coords.x, coords.y, coords.z);
                sprite.scale.set(0.5, 0.5, 1); // ch·ªânh size spot
                world.scene().add(sprite);
            });




            world.globeMaterial(material)
                .backgroundImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/night-sky.png')
                .onZoom(({ lng, lat }) => material.uniforms.globeRotation.value.set(lng, lat));

            const now = new Date();
            timeEl.textContent = now.toUTCString();
            material.uniforms.sunPosition.value.set(...sunPosAt(+now));

            // const impacts = [
            //     { lat: 10.75, lon: 106.67, radius: 200, name: 'Asteroid A' }, // TP.HCM
            //     { lat: 35.68, lon: 139.76, radius: 100, name: 'Asteroid B' }  // Tokyo
            // ];

            // world
            //     .ringsData(impacts)
            //     .ringLat(d => d.lat)
            //     .ringLng(d => d.lon)
            //     .ringAltitude(0.002)
            //     .ringColor(() => t => `rgba(255,100,0,${1 - t})`)
            //     .ringMaxRadius(d => d.radius * 1000)
            //     .ringPropagationSpeed(5)
            //     .ringRepeatPeriod(3000);


        });
    </script>
</body>